import{_ as a,o as n,c as l,Q as p}from"./chunks/framework.b6910bb2.js";const o="/vitePress-blob/assets/1.4d5a2b6a.gif",e="/vitePress-blob/assets/image-3.bc73d938.png",s="/vitePress-blob/assets/2.05638152.gif",t="/vitePress-blob/assets/image-4.7e66fc23.png",r="/vitePress-blob/assets/image-5.c2db871f.png",A=JSON.parse('{"title":"如何实现点选物体","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Fabric.js/如何实现点选物体.md","filePath":"guide/Fabric.js/如何实现点选物体.md","lastUpdated":1736992546000}'),c={name:"guide/Fabric.js/如何实现点选物体.md"},i=p('<h1 id="如何实现点选物体" tabindex="-1">如何实现点选物体 <a class="header-anchor" href="#如何实现点选物体" aria-label="Permalink to &quot;如何实现点选物体&quot;">​</a></h1><p>上一节，我们了解了在 Fabric.js 中，可以通过 <code>transform</code> 进行矩阵运算，从而达到平移、旋转、缩放的目的。</p><p>接下来我们将了解如何对一个物体进行点选，在 Fabric.js 的表现即鼠标移动到元素上，呈现hover状态，移出则显示默认状态。</p><p><img src="'+o+'" alt="点选效果"></p><h2 id="判断是否在矩形内部" tabindex="-1">判断是否在矩形内部 <a class="header-anchor" href="#判断是否在矩形内部" aria-label="Permalink to &quot;判断是否在矩形内部&quot;">​</a></h2><p>如果对于矩形元素来说, 我们可以获取到四个顶点的坐标，进而判断当前的鼠标坐标是否在顶点坐标之内即可。</p><p>例如矩形的左上角顶点坐标是 left、top</p><p>那么我们只需要判断 <code>left &lt;= x &lt;= left + width &amp;&amp; top &lt;= y &lt;= top + height</code> 即可。</p><p>基于此，在 Fabric.js 静态层 Canvas 会有一个 <code>_objects</code> 数组，存储了所有图形的数据，</p><p>此时可以通过从后往前遍历（因为最后添加元素位于数组最后）判断鼠标点是否在元素上。</p><h2 id="包围盒" tabindex="-1">包围盒 <a class="header-anchor" href="#包围盒" aria-label="Permalink to &quot;包围盒&quot;">​</a></h2><p>对于其他图形，例如三角形等，可以引入包围盒的概念，将其他图形转化为矩形进行判断。</p><p>常见的有 OBB、AABB、球模型包围盒</p><p><img src="'+e+'" alt="alt text"></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>AABB（轴对齐包围盒）</strong></td><td>边与坐标轴对齐，由最小点和最大点定义</td><td>计算简单，存储效率高</td><td>对旋转物体可能不紧凑，浪费空间</td><td>静态场景筛选，粗略碰撞检测</td></tr><tr><td><strong>OBB（方向包围盒）</strong></td><td>可任意旋转，由中心点、尺寸向量和旋转矩阵描述</td><td>更紧凑地包围旋转物体</td><td>计算复杂度高</td><td>精确碰撞检测，动态物体包围</td></tr><tr><td><strong>球模型包围盒</strong></td><td>以中心点和半径定义</td><td>旋转无影响，检测简单</td><td>对非球状物体浪费较多空间</td><td>初步碰撞检测，三维场景快速筛选</td></tr></tbody></table><p><img src="'+s+'" alt="alt text"></p><p>我们不难发现，在 Fabric.js 中也是通过 AABB 包围盒进行点选物体的。</p><p>演示地址: <a href="https://enson0131.github.io/mini-fabric-whiteboard/" target="_blank" rel="noreferrer">https://enson0131.github.io/mini-fabric-whiteboard/</a></p><h2 id="点射法" tabindex="-1">点射法 <a class="header-anchor" href="#点射法" aria-label="Permalink to &quot;点射法&quot;">​</a></h2><p>对于矩形，我们可以很方便地计算出点是否在矩形内，在不借助包围盒的情况下，是否可以判断点在多边形内呢？</p><p>显然是可以的，常见的算法是 <code>点射法</code>，这种方法的核心思想是通过从目标点 P(x,y) 向任意方向发射一条射线，通常选择水平或垂直方向以简化计算，然后统计射线与几何区域的边或面相交的次数。</p><ol><li><p>如果射线与边/面的交点数是奇数，点在多边形内部。</p></li><li><p>如果交点数是偶数，点在多边形外部。</p></li></ol><p>大致可以在脑海里想象下👇</p><p><img src="'+t+'" alt="alt text"></p><p>应该有不少同学已经想象到一些边界场景：</p><ol><li><p>点在多边形的顶点上</p></li><li><p>点所在的射线穿过图形的顶点上</p></li><li><p>点的射线穿过图形的一条边</p></li></ol><p><img src="'+r+`" alt="alt text"></p><p>基于第一种场景，可以通过业务场景决定是否在多边形内/外。</p><p>基于第二种场景，常见的会将其判断为一个交点，而第三种场景则可以简单判断为无交点。</p><p>通过 <code>点射法</code>，我们可以将问题转化为射线与多边形各个边的交点，也就是简化成了求解一元线性方程组。</p><p>数学原理:</p><pre><code>射线方程：\`y = b1x + a1\`

边界线段方程：\`y = b2x + a2\`

交点处：\`b1x + a1 = b2x + a2\`

求解x坐标：x = \`-(a1 - a2)/(b1 - b2)\`。
</code></pre><p>下面是一些伪代码:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">b1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// b1 / b2 是斜率</span></span>
<span class="line"><span style="color:#E1E4E8;">  b2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (iLine.d.y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> iLine.o.y) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (iLine.d.x </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> iLine.o.x); </span><span style="color:#6A737D;">// iLine.d 多边形线段的终点、iLine.o 是多边形线段的起点</span></span>
<span class="line"><span style="color:#E1E4E8;">  a1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ey </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b1 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> ex;</span></span>
<span class="line"><span style="color:#E1E4E8;">  a2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> iLine.o.y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b2 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> iLine.o.x;</span></span>
<span class="line"><span style="color:#E1E4E8;">  xi </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">(a1 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> a2) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (b1 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b2); </span><span style="color:#6A737D;">// 求俩个直接的交点，即求出交点的 x 坐标 即 xi = a1 - a2 / b2;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">b1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// b1 / b2 是斜率</span></span>
<span class="line"><span style="color:#24292E;">  b2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (iLine.d.y </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> iLine.o.y) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (iLine.d.x </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> iLine.o.x); </span><span style="color:#6A737D;">// iLine.d 多边形线段的终点、iLine.o 是多边形线段的起点</span></span>
<span class="line"><span style="color:#24292E;">  a1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ey </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b1 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> ex;</span></span>
<span class="line"><span style="color:#24292E;">  a2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> iLine.o.y </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b2 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> iLine.o.x;</span></span>
<span class="line"><span style="color:#24292E;">  xi </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">(a1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> a2) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (b1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b2); </span><span style="color:#6A737D;">// 求俩个直接的交点，即求出交点的 x 坐标 即 xi = a1 - a2 / b2;</span></span></code></pre></div><h2 id="点在多边形内的其他方法" tabindex="-1">点在多边形内的其他方法 <a class="header-anchor" href="#点在多边形内的其他方法" aria-label="Permalink to &quot;点在多边形内的其他方法&quot;">​</a></h2><ol><li><p>用 canvas 自身的 api isPointInPath 传送门 👉: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath</a></p></li><li><p>将多边形切割成多个三角形，然后判断点是否在某个三角形内部</p></li><li><p>转角累加法（点连接各个顶点，计算夹角是否等于 360）</p></li><li><p>面积法 （点连接各个顶点形成三角形，计算面积是否等于图形的面积等）</p></li></ol><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><h3 id="优化1-记录最近的这个物体-下次再次判断这个物体" tabindex="-1">优化1: 记录最近的这个物体，下次再次判断这个物体 <a class="header-anchor" href="#优化1-记录最近的这个物体-下次再次判断这个物体" aria-label="Permalink to &quot;优化1: 记录最近的这个物体，下次再次判断这个物体&quot;">​</a></h3><p>细心的同学不难发现，鼠标在移动的时候，我们都需要判断是否点是否在物体上，开销比较大，常见可以使用 节流 的方式进行优化。</p><p>当然，还有另一种方式就是记录最近的这个物体，下次优先再次判断这个物体，因为我们会觉得选中过的物体，再次选中的概率会很大</p><h3 id="优化2-判断是否是透明区域" tabindex="-1">优化2: 判断是否是透明区域 <a class="header-anchor" href="#优化2-判断是否是透明区域" aria-label="Permalink to &quot;优化2: 判断是否是透明区域&quot;">​</a></h3><p><img src="`+s+`" alt="alt text"></p><p>如上图，我们发现，当我们鼠标命中包围盒时，并非完全命中物体，常见可以通过判断透明区域，是否命中物体。</p><p>例如当我们判断命中包围盒时，在通过当前坐标点获取周围的像素，例如通过 <code>ctx.getImageData</code>可以获取当前 ctx Canvas 图层的图像数据，再进而判断是否都是透明度为 0 的像素。如果是则为空白区域、否则命中🎯。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> isTransparent </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 判断是透明度</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">imageData</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctx.</span><span style="color:#B392F0;">getImageData</span><span style="color:#E1E4E8;">(x, y, width, height);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> imageData.data.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 只要看第四项透明度即可</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> imageData.data[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    isTransparent </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (isTransparent </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 找到一个颜色就停止</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> isTransparent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 判断是透明度</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">imageData</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctx.</span><span style="color:#6F42C1;">getImageData</span><span style="color:#24292E;">(x, y, width, height);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> imageData.data.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 只要看第四项透明度即可</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> imageData.data[i];</span></span>
<span class="line"><span style="color:#24292E;">    isTransparent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (isTransparent </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 找到一个颜色就停止</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection</a></li><li><a href="https://kenshin.tech/page/2/" target="_blank" rel="noreferrer">https://kenshin.tech/page/2/</a></li><li><a href="https://juejin.cn/post/7111245657557434398" target="_blank" rel="noreferrer">https://juejin.cn/post/7111245657557434398</a></li></ul>`,47),y=[i];function E(d,h,b,g,D,m){return n(),l("div",null,y)}const _=a(c,[["render",E]]);export{A as __pageData,_ as default};
