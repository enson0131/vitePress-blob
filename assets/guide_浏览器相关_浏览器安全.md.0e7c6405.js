import{_ as l,o as i,c as e,Q as a}from"./chunks/framework.b6910bb2.js";const o="/vitePress-blob/assets/6.36673f2f.jpg",t="/vitePress-blob/assets/7.d0aefc74.jpg",r="/vitePress-blob/assets/8.28d1dcd9.jpg",s="/vitePress-blob/assets/9.b32cc031.jpg",q=JSON.parse('{"title":"浏览器安全","description":"","frontmatter":{},"headers":[],"relativePath":"guide/浏览器相关/浏览器安全.md","filePath":"guide/浏览器相关/浏览器安全.md","lastUpdated":1708499897000}'),n={name:"guide/浏览器相关/浏览器安全.md"},c=a('<h1 id="浏览器安全" tabindex="-1">浏览器安全 <a class="header-anchor" href="#浏览器安全" aria-label="Permalink to &quot;浏览器安全&quot;">​</a></h1><h2 id="页面安全" tabindex="-1">页面安全 <a class="header-anchor" href="#页面安全" aria-label="Permalink to &quot;页面安全&quot;">​</a></h2><h3 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h3><p>协议、域名、端口号都相同，才是同源。</p><h4 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h4><ol><li>无法进行 DOM 操作</li><li>无法获取 Cookie、LocalStorage 等数据</li><li>无法向不同源发请求</li></ol><h4 id="开放" tabindex="-1">开放 <a class="header-anchor" href="#开放" aria-label="Permalink to &quot;开放&quot;">​</a></h4><ol><li><p>默认页面中可以引用任意第三方资源</p><p>引入 CSP (内容安全策略)</p><p><img src="'+o+'" alt="渲染流程图"></p></li><li><p>只能请求同源的接口</p><p>引入 CORS (跨域资源共享)</p><ul><li><p>简单请求 （HEAD/POST/GET请求）</p><ol><li>浏览器在请求头上添加 Oirgin 字段，该字段用来说明请求来自那个源，服务器可以根据这个值决定是否同意这次请求</li><li>当服务器收到请求后，根据 Origin 判断是否在许可范围内</li><li>如果不在范围内，服务器会返回一个正常的 HTTP 响应，浏览器发现该响应头没有包含 Access-Control-Allow-Origin 字段，就会抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获 （由于正常响应，其状态码是 200，所以该错误不能通过状态码识别）</li><li>如果 Origin 在指定范围内，服务器返回的响应会多几个头信息字段 <ul><li><p>Access-Control-Allow-Origin（必须） 判断源是否可以跨域，该值要么是请求的 Origin，要么是 *</p></li><li><p>Access-Control-Allow-Credentials 是否允许发送 Cookie，默认为 false 如果 Access-Control-Allow-Origin 的值为 *，则无法发送 Cookie</p></li><li><p>Access-Control-Expose-Headers 制定其他的头信息字段可以暴露给客户端 因为默认情况下，只有 6 个字段可以被暴露，其他的都会被过滤掉</p><p><img src="'+t+'" alt="简单请求"></p></li></ul></li></ol></li><li><p>非简单请求 （PUT/DELETE 或者 Content-type字段类型是 application/json）</p><ol><li>浏览器发起 Option 预检请求</li><li>服务器收到预检请求后，检查 <ul><li>Origin 发起请求的源信息</li><li>Access-Control-Request-Method 浏览器会发起请求的方法</li><li>Access-Control-Request-Headers 请求额外发送的头信息字段</li></ul></li><li>如果服务器否定预检请求，会返回一个正常的 HTTP 响应，但是没有任何的 CORS 相关的头信息字段，这是浏览器会认定服务器不同意预检，触发错误</li><li>如果服务器同意预检请求，会返回一个正常的 HTTP 响应，但是会多几个 CORS 相关的头信息字段 <ul><li>Access-Control-Allow-Origin （必须）</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Expose-Headers</li><li>Access-Control-Max-Age - 预检请求的有效期, 单位秒</li><li>Access-Control-Allow-Methods （必须）</li><li>Access-Control-Allow-Headers</li></ul></li></ol><p><img src="'+r+'" alt="非简单请求"></p></li></ul></li><li><p>只能操作同源的DOM 引入了跨文档消息机制 postMessage</p></li></ol><h3 id="xss-攻击" tabindex="-1">XSS 攻击 <a class="header-anchor" href="#xss-攻击" aria-label="Permalink to &quot;XSS 攻击&quot;">​</a></h3><p>跨域脚本攻击。</p><h4 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h4><ol><li><p>存储型</p><p>脚本存储在服务器，用户访问时，脚本从服务器返回，浏览器执行脚本</p></li><li><p>反射型</p><p>在文章链接参数上存放了一段恶意脚本，用户访问时，脚本从参数中取出，浏览器执行脚本</p></li><li><p>DOM 型</p><p>比如在搜索的时候，添加了一段脚本， 如果网站的搜索功能没有对用户输入进行适当的过滤和转义，搜索结果页面可能会将恶意的脚本代码直接插入到 HTML 中，并在用户浏览器中执行</p><p>web 资源在传输或者用户在使用的过程中修改了 Web 页面的数据</p></li></ol><h4 id="预防" tabindex="-1">预防 <a class="header-anchor" href="#预防" aria-label="Permalink to &quot;预防&quot;">​</a></h4><ol><li>对输入的内容进行截取或者转义（encode）</li><li>限制输入的长度和类型</li><li>引入内容安全策略 （CSP）</li><li>对 Cookie 设置 HttpOnly 属性</li></ol><h3 id="csrf-攻击" tabindex="-1">CSRF 攻击 <a class="header-anchor" href="#csrf-攻击" aria-label="Permalink to &quot;CSRF 攻击&quot;">​</a></h3><p>跨站请求伪造。</p><p>比如诱导用户点击链接，访问网址后，网址通过用户的登录信息伪造请求</p><h4 id="必要条件" tabindex="-1">必要条件 <a class="header-anchor" href="#必要条件" aria-label="Permalink to &quot;必要条件&quot;">​</a></h4><ol><li>站点有 CSRF 漏洞</li><li>用户登录了</li><li>用户点击了诱导链接</li></ol><h4 id="预防-1" tabindex="-1">预防 <a class="header-anchor" href="#预防-1" aria-label="Permalink to &quot;预防&quot;">​</a></h4><ol><li>给 Cookie 新增 SameSite 属性 <ul><li>Strict: 第三方站点无法发送 Cookie</li><li>Lax (默认): 第三方站点如果是 GET 请求可以发送 Cookie</li><li>None 不做限制 <img src="'+s+'" alt="Cookie的书写"></li></ul></li><li>通过请求的 Origin or Referer 字段判断请求合法性</li><li>在请求地址中添加 token 并验证</li></ol><h2 id="浏览器安全-1" tabindex="-1">浏览器安全 <a class="header-anchor" href="#浏览器安全-1" aria-label="Permalink to &quot;浏览器安全&quot;">​</a></h2><p>将渲染进程放在沙箱中</p><ul><li>无法持久存储</li><li>无法访问网络</li><li>无法监听用户交互</li><li>需要通过 IPC 与浏览器主进程通信，由浏览器进程处理后，再将结果传递给渲染进程</li></ul><h2 id="网络安全" tabindex="-1">网络安全 <a class="header-anchor" href="#网络安全" aria-label="Permalink to &quot;网络安全&quot;">​</a></h2><p>HTTPS、重放攻击、验签</p>',26),p=[c];function h(d,u,_,b,C,m){return i(),e("div",null,p)}const f=l(n,[["render",h]]);export{q as __pageData,f as default};
