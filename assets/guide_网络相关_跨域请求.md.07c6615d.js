import{_ as e,o,c as i,Q as a}from"./chunks/framework.b6910bb2.js";const l="/vitePress-blob/assets/7.d0aefc74.jpg",t="/vitePress-blob/assets/8.28d1dcd9.jpg",m=JSON.parse('{"title":"跨域请求","description":"","frontmatter":{},"headers":[],"relativePath":"guide/网络相关/跨域请求.md","filePath":"guide/网络相关/跨域请求.md","lastUpdated":1706512206000}'),s={name:"guide/网络相关/跨域请求.md"},r=a('<h1 id="跨域请求" tabindex="-1">跨域请求 <a class="header-anchor" href="#跨域请求" aria-label="Permalink to &quot;跨域请求&quot;">​</a></h1><h2 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-label="Permalink to &quot;简单请求&quot;">​</a></h2><p>若请求满足<strong>所有</strong>下述条件，则该请求可视为简单请求：</p><ol><li>HEAD/GET/POST 请求</li><li>Content-Type: text/plain、multipart/form-data、application/x-www-form-urlencoded</li><li>除了被用户代理自动设置的标头字段，剩下的请求头是: Accept、Accept-Language、Content-Language、Content-Type、Range</li></ol><h3 id="请求过程" tabindex="-1">请求过程 <a class="header-anchor" href="#请求过程" aria-label="Permalink to &quot;请求过程&quot;">​</a></h3><ol><li>发起请求，请求头会带上 Origin 字段，该字段用来说明请求来自哪个源（协议 + 域名 + 端口），服务器根据这个值决定是否同意这次请求</li><li>当服务器接收到请求后，根据 Origin 判断是否在允许的范围内</li><li>如果不在范围内，服务器会返回一个正常的 HTTP 响应，浏览器发现响应头信息没有 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出错误，被 XML 的 onerror 回调函数捕获。（注意：由于正常响应，其状态码为200，因此该错误不能通过状态码识别）</li><li>如果 Origin 指定的域名在范围内，服务器返回的响应会多出几个头信息字段（Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Header 等）</li></ol><p><img src="'+l+'" alt="流程"></p><h2 id="非简单请求" tabindex="-1">非简单请求 <a class="header-anchor" href="#非简单请求" aria-label="Permalink to &quot;非简单请求&quot;">​</a></h2><p>请求方法是 PUT、DELETE 或者 Content-Type 是 application/json 类型</p><h3 id="请求过程-源、请求头、方法、缓存、cookie" tabindex="-1">请求过程 （源、请求头、方法、缓存、Cookie） <a class="header-anchor" href="#请求过程-源、请求头、方法、缓存、cookie" aria-label="Permalink to &quot;请求过程 （源、请求头、方法、缓存、Cookie）&quot;">​</a></h3><ol><li>浏览器发起 Option 预检请求</li><li>服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段后，确认允许跨域请求，就可以做出回应 <ul><li>Origin (必须): 发起请求的源信息</li><li>Access-Control-Request-Method（必须）: 用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法</li><li>Access-Control-Request-Headers 跨域请求而外的请求头字段</li></ul></li><li>如果服务器预检请求，会返回一个正常的 HTTP 回应，但没有任何的 CORS 相关的头信息字段，这时浏览器就会认定服务器不同意预检请求，触发错误。</li><li>如果服务器通过了预检请求，以后每次浏览器正常的 CORS 请求就跟简单请求一样 <ul><li>Access-Control-Allow-Origin（必须）: 运行哪些源跨域，如果是 * 无法携带 Cookie</li><li>Access-Control-Allow-Method（必须）: 服务器支持哪些请求</li><li>Access-Control-Allow-Header: 服务器支持的头信息字段</li><li>Access-Control-Max-Age: 预检请求的有效期，单位秒</li></ul></li></ol><p><img src="'+t+'" alt="流程"></p><h2 id="跨域请求如何传输-cookie" tabindex="-1">跨域请求如何传输 cookie <a class="header-anchor" href="#跨域请求如何传输-cookie" aria-label="Permalink to &quot;跨域请求如何传输 cookie&quot;">​</a></h2><ol><li>响应头设置 Access-Control-Allow-Credentials 等于 true</li><li>Access-Control-Allow-Origin 不能设置成 * （Cookie 的 SameSite 属性如果是 Lax 可能也会导致带不上去）</li><li>前端设置 withCredentials: true</li></ol><h2 id="常见的问题" tabindex="-1">常见的问题 <a class="header-anchor" href="#常见的问题" aria-label="Permalink to &quot;常见的问题&quot;">​</a></h2><h3 id="session-和-cookie-有什么区别" tabindex="-1">session 和 cookie 有什么区别？ <a class="header-anchor" href="#session-和-cookie-有什么区别" aria-label="Permalink to &quot;session 和 cookie 有什么区别？&quot;">​</a></h3><p>cookie 一般用于登录验证，存储用户信息，大小为 4KB，会随着网络请求携带给服务端</p><p>session 一般存储在服务端，常用于与 Cookie 配合做登录检验</p><h3 id="token-和-cookie-有什么区别" tabindex="-1">token 和 cookie 有什么区别？ <a class="header-anchor" href="#token-和-cookie-有什么区别" aria-label="Permalink to &quot;token 和 cookie 有什么区别？&quot;">​</a></h3><h3 id="cookie-的字段有哪些" tabindex="-1">Cookie 的字段有哪些？ <a class="header-anchor" href="#cookie-的字段有哪些" aria-label="Permalink to &quot;Cookie 的字段有哪些？&quot;">​</a></h3><h3 id="session-和-jwt-哪个更合适" tabindex="-1">Session 和 JWT 哪个更合适？ <a class="header-anchor" href="#session-和-jwt-哪个更合适" aria-label="Permalink to &quot;Session 和 JWT 哪个更合适？&quot;">​</a></h3><h3 id="如何实现-sso-单点登录" tabindex="-1">如何实现 SSO 单点登录 <a class="header-anchor" href="#如何实现-sso-单点登录" aria-label="Permalink to &quot;如何实现 SSO 单点登录&quot;">​</a></h3>',22),n=[r];function c(d,h,u,k,p,_){return o(),i("div",null,n)}const A=e(s,[["render",c]]);export{m as __pageData,A as default};
