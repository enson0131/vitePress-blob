import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.b6910bb2.js";const p="/vitePress-blob/assets/9.a690b18c.png",F=JSON.parse('{"title":"Embedding 之大规模数据拆分","description":"","frontmatter":{},"headers":[],"relativePath":"guide/ai/Embedding之大规模数据拆分.md","filePath":"guide/ai/Embedding之大规模数据拆分.md","lastUpdated":1737448252000}'),o={name:"guide/ai/Embedding之大规模数据拆分.md"},e=l(`<h1 id="embedding-之大规模数据拆分" tabindex="-1">Embedding 之大规模数据拆分 <a class="header-anchor" href="#embedding-之大规模数据拆分" aria-label="Permalink to &quot;Embedding 之大规模数据拆分&quot;">​</a></h1><p>受限于常见 LLM 的上下文大小，例如 gpt3.5t 是 16k、gpt4t 是 128k，我们并不能把完整的数据整个塞到对话的上下文中。</p><p>即使数据源接近于 LLM 的上下文窗口大小，llm 在读取数据时很容易出现分神，或者忽略其中部分细节的问题。</p><p>因此，我们需要对数据进行拆分，然后将最关联的内容输入给 LLM，以便 LLM 能够更好的理解数据。</p><h2 id="分割数据" tabindex="-1">分割数据 <a class="header-anchor" href="#分割数据" aria-label="Permalink to &quot;分割数据&quot;">​</a></h2><p>对于分割来说，将数据分割成具有独立逻辑的段落是比较好的选择，段落分割的质量越高，意味着 RAG 的效果越好，LLM 返回数据的质量就越好。</p><p>langchain 目前提供的切分工具有：</p><ul><li>Recursive: 根据给定的切分字符（例如 \\n\\n、\\n等），递归的切分</li><li>HTML: 根据 html 特定字符进行切分</li><li>Markdown: 根据 md 的特定字符进行切分</li><li>Code: 根据不同编程语言的特定字符进行切分</li><li>Token: 根据文本块的 token 数据进行切分</li><li>Character: 根据用户给定的字符进行切割</li></ul><h2 id="recursivecharactertextsplitter" tabindex="-1">RecursiveCharacterTextSplitter <a class="header-anchor" href="#recursivecharactertextsplitter" aria-label="Permalink to &quot;RecursiveCharacterTextSplitter&quot;">​</a></h2><p>RecursiveCharacterTextSplitter 默认的分隔符列表是 [&quot;\\n\\n&quot;, &quot;\\n&quot;, &quot; &quot;, &quot;&quot;], 你可以理解为它将文本分割后，在根据设置的 chunk 大小进行组装。</p><p>最影响切分质量的就是两个参数：</p><ul><li>chunkSize: 定义切分块的大小</li><li>chunkOverlap: 定义块与块之间重叠的大小。较大的重叠可能会导致分割的内容重复，较小的重叠可能会导致分割的内容不完整。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// RecursiveCharacterTextSplitter 对文本进行分割</span></span>
<span class="line"><span style="color:#6A737D;">// https://chunkviz.up.railway.app/</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { RecursiveCharacterTextSplitter } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;langchain/text_splitter&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { TextLoader } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;langchain/document_loaders/fs/text&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">text</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TextLoader</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;./data/kong.txt&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">docs</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> text.</span><span style="color:#B392F0;">load</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">splitter</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RecursiveCharacterTextSplitter</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    chunkSize: </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 分块的大小</span></span>
<span class="line"><span style="color:#E1E4E8;">    chunkOverlap: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 块之间的重叠</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">splitDocs</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> splitter.</span><span style="color:#B392F0;">splitDocuments</span><span style="color:#E1E4E8;">(docs);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(splitDocs);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// RecursiveCharacterTextSplitter 对文本进行分割</span></span>
<span class="line"><span style="color:#6A737D;">// https://chunkviz.up.railway.app/</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { RecursiveCharacterTextSplitter } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;langchain/text_splitter&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { TextLoader } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;langchain/document_loaders/fs/text&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">text</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TextLoader</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./data/kong.txt&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">docs</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> text.</span><span style="color:#6F42C1;">load</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">splitter</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RecursiveCharacterTextSplitter</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">    chunkSize: </span><span style="color:#005CC5;">64</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 分块的大小</span></span>
<span class="line"><span style="color:#24292E;">    chunkOverlap: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 块之间的重叠</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">splitDocs</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> splitter.</span><span style="color:#6F42C1;">splitDocuments</span><span style="color:#24292E;">(docs);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(splitDocs);</span></span></code></pre></div><p><img src="`+p+'" alt="输出结果"></p>',14),t=[e];function c(r,i,E,y,d,u){return a(),n("div",null,t)}const _=s(o,[["render",c]]);export{F as __pageData,_ as default};
