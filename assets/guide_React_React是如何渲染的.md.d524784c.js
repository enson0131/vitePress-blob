import{_ as e,o as t,c as a,Q as o}from"./chunks/framework.b6910bb2.js";const r="/vitePress-blob/assets/3.9b1f9060.png",s="/vitePress-blob/assets/4.f4dd49d0.png",c="/vitePress-blob/assets/5.34ee565e.png",i="/vitePress-blob/assets/6.121ea6f5.png",n="/vitePress-blob/assets/7.3f678f52.png",p="/vitePress-blob/assets/8.9d04f238.png",l="/vitePress-blob/assets/9.bae86652.png",k=JSON.parse('{"title":"React 是如何渲染的","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/React是如何渲染的.md","filePath":"guide/React/React是如何渲染的.md","lastUpdated":1698033755000}'),_={name:"guide/React/React是如何渲染的.md"},d=o('<h1 id="react-是如何渲染的" tabindex="-1">React 是如何渲染的 <a class="header-anchor" href="#react-是如何渲染的" aria-label="Permalink to &quot;React 是如何渲染的&quot;">​</a></h1><h2 id="react-16-以前" tabindex="-1">React 16 以前 <a class="header-anchor" href="#react-16-以前" aria-label="Permalink to &quot;React 16 以前&quot;">​</a></h2><p>在浏览器中 js 线程与渲染线程是互斥的，如果 js 线程长期占用着浏览器的主线程，那么界面将长时间不更新，在动画等一些场景下会造成卡顿效果。</p><p>因为 Stack Reconciler 是一个同步的递归过程，随着业务复杂度增加，Stack Reconciler 需要的调和时间会变长，</p><p>这意味着 js 将长时间占用浏览器，进而导致页面卡顿</p><p><img src="'+r+'" alt="Stack Reconciler"></p><h2 id="react-16-以后" tabindex="-1">React 16 以后 <a class="header-anchor" href="#react-16-以后" aria-label="Permalink to &quot;React 16 以后&quot;">​</a></h2><p>将同步执行的 Stack Reconciler 替换成了异步可中断的 Fiber Reconciler</p><p><img src="'+s+'" alt="Fiber Reconciler"></p><p>在更新时，每个任务会被赋予一个优先级，当任务抵达调度器时，高优先级的任务会更快抵达协调器，如有新的更高优先级的任务进入调度器时，当前协调器的任务就会被中断，更高优先级的任务将进入 reconciler</p><p><img src="'+c+'" alt="Fiber Reconciler"></p><p>新的架构会导致部分生命周期重复执行:</p><ul><li>componentWillMount</li><li>componentWillUpdate</li><li>showComponentUpdate</li><li>componentWillReceiveProps</li></ul><h2 id="mount-阶段" tabindex="-1">Mount 阶段 <a class="header-anchor" href="#mount-阶段" aria-label="Permalink to &quot;Mount 阶段&quot;">​</a></h2><p>在执行 ReactDOM.render 时去挂载组件，会创建 reactRootContainer 对象（也就是挂载的容器对象）, reactRootContainer 对象中会创建 FiberRootNode 对象（也就是根节点对象）</p><p>最终返回挂载组件( App组件 )的实例对象。</p><p><img src="'+i+'" alt="Mount 渲染过程"></p><p><img src="'+n+'" alt="FiberRootNode对象的描述"></p><p>在 fiberRoot 对象（ FiberRootNode ）中的 current 属性将指向 rootFiber 对象 （根节点Fiber，即 FiberNode 实例）</p><p><img src="'+p+'" alt="fiberRoot对象指向 rootFiber 根节点Fiber"></p><p><img src="'+l+'" alt="挂载创建关系图"></p>',21),b=[d];function m(R,h,u,f,g,P){return t(),a("div",null,b)}const v=e(_,[["render",m]]);export{k as __pageData,v as default};
