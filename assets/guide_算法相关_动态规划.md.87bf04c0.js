import{_ as e,o as a,c as o,Q as l}from"./chunks/framework.b6910bb2.js";const f=JSON.parse('{"title":"动态规划","description":"","frontmatter":{},"headers":[],"relativePath":"guide/算法相关/动态规划.md","filePath":"guide/算法相关/动态规划.md","lastUpdated":1762482662000}'),i={name:"guide/算法相关/动态规划.md"},d=l('<h1 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h1><h2 id="什么时候用动态规划" tabindex="-1">什么时候用动态规划 <a class="header-anchor" href="#什么时候用动态规划" aria-label="Permalink to &quot;什么时候用动态规划&quot;">​</a></h2><ol><li>要求你给出达成某个目的的解法个数</li><li>不要求你给出每一种解法对应的具体路径</li></ol><h2 id="思路分析" tabindex="-1">思路分析 <a class="header-anchor" href="#思路分析" aria-label="Permalink to &quot;思路分析&quot;">​</a></h2><ul><li>由 总 --&gt; 分的思路，倒着推，将问题拆解成子问题求解</li><li>将总问题抽象成函数 f(n)</li><li>将子问题抽象成函数 f(n-1)</li><li>那么总问题的解决方法就是 f(n) = f(n-1) + X</li></ul><p>这样从 总 到 分 的思考方式是 <code>自顶向下</code> 的思路。</p><h2 id="编码实现" tabindex="-1">编码实现 <a class="header-anchor" href="#编码实现" aria-label="Permalink to &quot;编码实现&quot;">​</a></h2><h3 id="实现方式1-递归" tabindex="-1">实现方式1 - 递归 <a class="header-anchor" href="#实现方式1-递归" aria-label="Permalink to &quot;实现方式1 - 递归&quot;">​</a></h3><p>基于思路分析，我们可以实现一个递归的函数，来解决这个问题。</p><p>但递归可能会存在重复计算的问题，所以我们可以使用一个<code>缓存</code>来存储已经计算过的结果，这样就可以避免重复计算。</p><p>符合 <code>自顶向下</code> 的思考方式。</p><h3 id="实现方式2-动态规划" tabindex="-1">实现方式2 - 动态规划 <a class="header-anchor" href="#实现方式2-动态规划" aria-label="Permalink to &quot;实现方式2 - 动态规划&quot;">​</a></h3><p>动态规划则恰恰相反，是一个<code>自底向上</code>的过程。它要求我们站在<code>已知</code>的角度，通过定位<code>已知</code>和<code>未知</code>之间的关系(状态转移方程)，一步一步向前推导，进而求解出未知的值。</p><p>符合 <code>自底向上</code> 的思考方式。</p><h2 id="与-分治-的区别" tabindex="-1">与 分治 的区别 <a class="header-anchor" href="#与-分治-的区别" aria-label="Permalink to &quot;与 分治 的区别&quot;">​</a></h2><p>分治问题的核心思想是：把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解。</p><p>动态规划的思想和 <code>分治</code> 有点相似。</p><p><code>分治</code> 思想中，各个子问题之间是<code>独立</code>的：比如说归并排序中，子数组之间的排序并不互相影响。</p><p>而动态规划划分出的子问题，往往是<code>相互依赖</code>、<code>相互影响</code>的。</p><p>什么样的题应该用动态规划来做？我们要抓以下两个关键特征：</p><ul><li>最优子结构 - 问题的最优解就是子问题的最优解</li><li>重叠子问题 - 子问题之间有重叠</li></ul><h2 id="动态规划问题的分析技巧" tabindex="-1">动态规划问题的分析技巧 <a class="header-anchor" href="#动态规划问题的分析技巧" aria-label="Permalink to &quot;动态规划问题的分析技巧&quot;">​</a></h2><ul><li>自顶向下：树形思维模型将帮助我们更迅速地定位到状态转移关系</li><li>结合记忆化搜索，明确状态转移方程</li><li>递归代码转化为迭代表达</li></ul>',23),t=[d];function c(r,h,n,s,p,_){return a(),o("div",null,t)}const m=e(i,[["render",c]]);export{f as __pageData,m as default};
