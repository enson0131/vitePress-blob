import{_ as l,o as i,c as a,Q as e}from"./chunks/framework.b6910bb2.js";const t="/vitePress-blob/assets/3.8bc85ddd.png",o="/vitePress-blob/assets/4.9caf6b36.png",b=JSON.parse('{"title":"浏览器渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"guide/浏览器相关/浏览器渲染流程.md","filePath":"guide/浏览器相关/浏览器渲染流程.md","lastUpdated":1705660482000}'),r={name:"guide/浏览器相关/浏览器渲染流程.md"},s=e('<h1 id="浏览器渲染流程" tabindex="-1">浏览器渲染流程 <a class="header-anchor" href="#浏览器渲染流程" aria-label="Permalink to &quot;浏览器渲染流程&quot;">​</a></h1><h2 id="浏览器渲染流程-1" tabindex="-1">浏览器渲染流程 <a class="header-anchor" href="#浏览器渲染流程-1" aria-label="Permalink to &quot;浏览器渲染流程&quot;">​</a></h2><ol><li>发出请求到页面首次绘制 <ul><li>第一阶段: 页面提交请求到服务器响应，这时候页面还是之前的页面</li><li>第二阶段: 获取到响应数据提交到渲染进程，进行 HTML 解析、CSS 加载、JS 加载、JS 执行、CSSOM 解析、布局树生成、页面绘制</li><li>第三阶段: 等首次加载完成后，页面一点点被渲染</li></ul></li><li>HTML 解析</li><li>生成 CSSOM 树 CSS 不会阻塞 HTML 解析，但是会阻塞页面渲染，因为要生成渲染树</li><li>生成布局树 去除不显示的节点，计算样式</li><li>分层和合成机制 <ul><li>分层: 分层树在布局树之后，分层树的每一个节点都是图层，如没有，则和父节点同一个图层</li><li>绘制阶段: 根据图层在绘制阶段生成绘制指令</li><li>光栅化: 根据绘制指令，将每个图层都绘制成一张图片</li><li>合成: 合成线程将多张图片合成一张图片，然后显示在屏幕上 (由合成线程完成，不影响主线程) - 优化操作1: 合成线程内会维护一个光栅化线程池，将绘制指令列表提交到 GPU 进行光栅化，生成位图，放在内存中 - 优化操作2: 分块，合成线程将图层分块，优先渲染离屏幕最近的图块 - <img src="'+t+'" alt="合成线程"></li></ul></li><li>页面显示</li></ol><h2 id="常见的问题" tabindex="-1">常见的问题 <a class="header-anchor" href="#常见的问题" aria-label="Permalink to &quot;常见的问题&quot;">​</a></h2><h3 id="_1-从输入-url-到页面渲染完成-发生了什么" tabindex="-1">1 从输入 URL 到页面渲染完成，发生了什么？ <a class="header-anchor" href="#_1-从输入-url-到页面渲染完成-发生了什么" aria-label="Permalink to &quot;1 从输入 URL 到页面渲染完成，发生了什么？&quot;">​</a></h3><ol><li>浏览器会根据用户输入的内容判断是关键字还是URL</li><li>如果是关键字，会将其组成成带有搜索关键字的URL，通过IPC进程通信发送给网络进程</li><li>网络进程发起请求前，会判断是否命中强缓存，如命中直接返回存储资源</li><li>否则发起请求，根据 DNS 解析获取域名对应的 IP 地址，进行 TCP、HTTP 连接</li><li>服务端收到请求后，会判断是否命中协商缓存，如命中则返回304状态码</li><li>如返回的是301、302状态码，浏览器会根据响应头返回的location字段，进行重定向</li><li>如是正常返回资源类型，浏览器会根据 content-type 对资源做相对应的操作，如果是下载类型则进行下载，如果是html类型则会提交到渲染进程进行解析</li><li>解析HTML，转换成浏览器能识别的DOM树</li><li>解析CSS，转化成浏览器能识别的CSS样式树</li><li>根据DOM和CSS样式树，通过布局计算生成布局树</li><li>根据布局树上的分层属性（z-index），生成分层树</li><li>根据分层树，生成绘制指令列表</li><li>渲染主线程会将绘制指令列表提交给合成线程</li><li>合成线程会发送指令给光栅化线程池，将绘制指令列表提交到 GPU 进行光栅化，生成位图，放在内存中</li><li>合成线程通信浏览器进程，浏览器进程将内存中的数据输出到显卡的后缓存区，在下一帧绘制之前，显卡的后缓冲区与前缓冲区对换，显示屏读取前缓冲区数据，显示到屏幕上</li></ol><p><img src="'+o+'" alt="整体流程"></p><h3 id="_2-回流和重绘有什么区别" tabindex="-1">2 回流和重绘有什么区别 <a class="header-anchor" href="#_2-回流和重绘有什么区别" aria-label="Permalink to &quot;2 回流和重绘有什么区别&quot;">​</a></h3><h3 id="_3-渲染流程图" tabindex="-1">3 渲染流程图 <a class="header-anchor" href="#_3-渲染流程图" aria-label="Permalink to &quot;3 渲染流程图&quot;">​</a></h3>',9),n=[s];function _(d,c,h,u,S,m){return i(),a("div",null,n)}const P=l(r,[["render",_]]);export{b as __pageData,P as default};
