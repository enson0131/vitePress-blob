import{_ as e,o as a,c as t,Q as i}from"./chunks/framework.b6910bb2.js";const k=JSON.parse('{"title":"React 中的 Diff 算法","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/diff算法.md","filePath":"guide/React/diff算法.md","lastUpdated":1718192676000}'),d={name:"guide/React/diff算法.md"},r=i('<h1 id="react-中的-diff-算法" tabindex="-1">React 中的 Diff 算法 <a class="header-anchor" href="#react-中的-diff-算法" aria-label="Permalink to &quot;React 中的 Diff 算法&quot;">​</a></h1><h2 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h2><p>React Diff 算法主要分单节点和多节点 Diff 算法 在单节点 Diff 算法中，会对比 key 和 tag 是否可以复用 如果 key 和 tag 都相同时，复用当前的 Fiber 节点，标记其他 Fiber 节点为删除 如果 key 不相同，标记删除当前的 Fiber 节点，对比下一个节点 如果 key 相同、tag 不同，则标记删除所有 Fiber 节点，生成新的 Fiber 节点</p><p>在多节点 Diff 中，有俩个 for 循环，第一个 for 循环判断可以复用的节点，记录最后可复用节点的 lastIndex 位置</p><p>通过 Map 建立节点和下标的对应关系，如果新节点的key可以在 Map 中找到，则复用旧节点，并判断新节点下标和 lastIndex 下标的关系， 如果新节点下标 &gt; lastIndex 下标，说明只需要更新节点，不需要移动位置，更新 lastIndex。 如果新节点下标 &lt; lastIndex，说明需要更新移动位置，不需要更新 lastIndex。</p><h1 id="单节点diff算法-render方法创建的element元素子节点只有一个" tabindex="-1">单节点diff算法 （render方法创建的element元素子节点只有一个） <a class="header-anchor" href="#单节点diff算法-render方法创建的element元素子节点只有一个" aria-label="Permalink to &quot;单节点diff算法 （render方法创建的element元素子节点只有一个）&quot;">​</a></h1><h2 id="_1-旧节点不存在" tabindex="-1">1. 旧节点不存在 <a class="header-anchor" href="#_1-旧节点不存在" aria-label="Permalink to &quot;1. 旧节点不存在&quot;">​</a></h2><ol><li>如果旧节点不存在，则直接新增节点</li></ol><h2 id="_2-旧节点存在" tabindex="-1">2. 旧节点存在 <a class="header-anchor" href="#_2-旧节点存在" aria-label="Permalink to &quot;2. 旧节点存在&quot;">​</a></h2><p>1 判断 key 和 tag 是否相同，相同则复用节点，更新属性 2 如果 key 相同但 tag 不相同，则删除所有节点 3 如果 key、tag 不同，则不需要复用，旧节点标记为删除</p><h1 id="多节点diff算法-render方法创建的element元素子节点有多个" tabindex="-1">多节点diff算法 （render方法创建的element元素子节点有多个） <a class="header-anchor" href="#多节点diff算法-render方法创建的element元素子节点有多个" aria-label="Permalink to &quot;多节点diff算法 （render方法创建的element元素子节点有多个）&quot;">​</a></h1><p>多节点diff有俩次 for 循环, 第一次 for 循环判断元素是否需要更新，第二次 for 循环判断元素是否需要移动位置</p><h2 id="_1-第一次-for-循环比较key和tag-如果相同则复用-并用-lastindex-标记当前可以复用的节点位置" tabindex="-1">1 第一次 for 循环比较key和tag, 如果相同则复用, 并用 lastIndex 标记当前可以复用的节点位置 <a class="header-anchor" href="#_1-第一次-for-循环比较key和tag-如果相同则复用-并用-lastindex-标记当前可以复用的节点位置" aria-label="Permalink to &quot;1 第一次 for 循环比较key和tag, 如果相同则复用, 并用 lastIndex 标记当前可以复用的节点位置&quot;">​</a></h2><h2 id="_2-遇到不相同时-跳出第一层-for-循环-创建一个-map-对象-存储旧节点的-key-和-index" tabindex="-1">2 遇到不相同时, 跳出第一层 for 循环, 创建一个 Map 对象, 存储旧节点的 key 和 index <a class="header-anchor" href="#_2-遇到不相同时-跳出第一层-for-循环-创建一个-map-对象-存储旧节点的-key-和-index" aria-label="Permalink to &quot;2 遇到不相同时, 跳出第一层 for 循环, 创建一个 Map 对象, 存储旧节点的 key 和 index&quot;">​</a></h2><ul><li>key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束</li><li>key 相同 type 不同导致不可复用，会将 oldFiber 标记为 DELETION，并继续遍历</li></ul><h2 id="_3-在-map-对象中查找新节点的-key-如果存在-则说明新节点可以复用旧节点-并且判断是否需要移动位置" tabindex="-1">3 在 Map 对象中查找新节点的 key, 如果存在, 则说明新节点可以复用旧节点, 并且判断是否需要移动位置 <a class="header-anchor" href="#_3-在-map-对象中查找新节点的-key-如果存在-则说明新节点可以复用旧节点-并且判断是否需要移动位置" aria-label="Permalink to &quot;3 在 Map 对象中查找新节点的 key, 如果存在, 则说明新节点可以复用旧节点, 并且判断是否需要移动位置&quot;">​</a></h2><h2 id="_4-如果-index-lastindex-则不需要移动位置-更新-lastindex" tabindex="-1">4 如果 index &gt; lastIndex, 则不需要移动位置, 更新 lastIndex <a class="header-anchor" href="#_4-如果-index-lastindex-则不需要移动位置-更新-lastindex" aria-label="Permalink to &quot;4 如果 index &gt; lastIndex, 则不需要移动位置, 更新 lastIndex&quot;">​</a></h2><h2 id="_5-如果-index-lastindex-则需要移动位置-不需要更新-lastindex" tabindex="-1">5 如果 index &lt; lastIndex, 则需要移动位置, 不需要更新 lastIndex <a class="header-anchor" href="#_5-如果-index-lastindex-则需要移动位置-不需要更新-lastindex" aria-label="Permalink to &quot;5 如果 index &lt; lastIndex, 则需要移动位置, 不需要更新 lastIndex&quot;">​</a></h2>',18),n=[r];function l(o,f,s,h,x,c){return a(),t("div",null,n)}const p=e(d,[["render",l]]);export{k as __pageData,p as default};
