import{_ as a,o as e,c as t,Q as r}from"./chunks/framework.b6910bb2.js";const o="/vitePress-blob/assets/4.8663f597.png",i="/vitePress-blob/assets/5.83f69d4f.png",f=JSON.parse('{"title":"3 基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"guide/javaScript相关/基础概念.md","filePath":"guide/javaScript相关/基础概念.md","lastUpdated":1705030853000}'),p={name:"guide/javaScript相关/基础概念.md"},l=r('<h1 id="_3-基础概念" tabindex="-1">3 基础概念 <a class="header-anchor" href="#_3-基础概念" aria-label="Permalink to &quot;3 基础概念&quot;">​</a></h1><h2 id="_3-1-闭包" tabindex="-1">3.1 闭包 <a class="header-anchor" href="#_3-1-闭包" aria-label="Permalink to &quot;3.1 闭包&quot;">​</a></h2><p>执行外部函数返回内部函数后，虽然外部函数已经弹出调用栈了，但是内部函数对外部函数变量的引用依然保存在内存中，那么内部函数和这些变量的集合就叫做闭包。</p><p>闭包的好处: 1. 私有变量在内存中持久化</p><p>闭包的坏处: 1. 使用不当会造成内存泄漏</p><h2 id="_3-2-原型" tabindex="-1">3.2 原型 <a class="header-anchor" href="#_3-2-原型" aria-label="Permalink to &quot;3.2 原型&quot;">​</a></h2><p>在 js 中对象是由构造函数创建的，构造函数中会有一个 prototype 属性，指向一个对象，这个对象包含了由该构造函数创建的实例所共享的属性和方法， 由该构造函数创建的实例可以通过 <strong>proto</strong> 属性指向这个对象，这个对象就是我们所说的原型。</p><p>当想要访问对象的某个属性时，如果在当前对象查找不到，就会往该对象的原型查找，对象的原型也会有属于他的原型对象，如此循环，直到 null 停止，这就是我们所说的原型链</p><p>隐式原型: <strong>proto</strong> 显示原型: prototype</p><p>相关方法: 1. hasOwnProperty() 判断属性是否是实例自身的属性 2. Object.getPrototypeOf() 获取实例的原型</p><h2 id="_3-3-作用域" tabindex="-1">3.3 作用域 <a class="header-anchor" href="#_3-3-作用域" aria-label="Permalink to &quot;3.3 作用域&quot;">​</a></h2><p>作用域分成<code>全局作用域</code>、<code>函数作用域</code>、<code>块级作用域</code>，它标识着一个变量是否合法 （编译过程中就已经确认了）</p><p>当查询一个变量时，如果当前作用域查询不到，会往上一级作用域查找，如此循环，直到全局作用域，这就是我们所说的作用域链</p><h2 id="_3-4-执行上下文" tabindex="-1">3.4 执行上下文 <a class="header-anchor" href="#_3-4-执行上下文" aria-label="Permalink to &quot;3.4 执行上下文&quot;">​</a></h2><p>从类型上看 1. 全局执行上下文 2. 函数执行上下文 3. eval 执行上下文</p><p>从生命周期上看 1. 创建阶段 - this 绑定 - 创建词法环境 （let、const会被提升到词法环境） - 创建变量环境 （var 声明的变量会被提升到变量环境） 2. 执行阶段 - 对变量进行赋值，执行代码 3. 回收阶段 - 当执行上下文弹出调用站后，会对上下文进行回收</p><p>执行上下文栈: 当 JS 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并压入执行栈中，当遇到函数调用时，就会为该函数创建一个新的函数执行上下文压入栈中， 引擎会执行位于执行上下文栈顶的函数，当函数执行完后，执行上下文会从栈中弹出，继续执行下一个上下文，当所有代码都执行完毕后，从栈中弹出全局执行上下文</p><p><img src="'+o+'" alt="执行上下文"></p><h2 id="_3-5-类数组对象" tabindex="-1">3.5 类数组对象 <a class="header-anchor" href="#_3-5-类数组对象" aria-label="Permalink to &quot;3.5 类数组对象&quot;">​</a></h2><p>一个拥有 length 属性和若干索引属性的对象就是类数组对象。</p><p>将类数组对象转化成数组的方法： 1 Array.from(arrayLike) 2 Array.prototype.slice.call(arrayLike) 3 Array.prototype.concat.apply([], arrayLike) 4 Array.prototype.splice.call(arrayLike, 0)</p><p>注意： <strong>类数组对象不一定有 iterator 接口，所以不能用拓展运算符</strong></p><p><img src="'+i+'" alt="类数组对象"></p><p>1 arguments 可以使用拓展运算符 2 可迭代对象（Iteratable Object，例如 [] ）与可枚举对象 (可以通过 for..in 遍历，例如 {} ) 不可用拓展运算符转化</p><h2 id="_3-6-严格模式" tabindex="-1">3.6 严格模式 <a class="header-anchor" href="#_3-6-严格模式" aria-label="Permalink to &quot;3.6 严格模式&quot;">​</a></h2><p>使用 use strict 即可声明严格模式</p><p>目的：</p><ul><li>消除 JavaScript 一些语法不合理、不严谨之处，减少怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li></ul><p>区别：</p><ul><li>禁止使用 with 语句</li><li>禁止 this 关键字指向全局对象</li><li>对象的属性名不能重复</li><li>arguments.callee 被禁止</li></ul><h2 id="_3-7-尾调用" tabindex="-1">3.7 尾调用 <a class="header-anchor" href="#_3-7-尾调用" aria-label="Permalink to &quot;3.7 尾调用&quot;">​</a></h2><p>在函数的最后一步调用另一个函数，称为尾调用（父函数执行上下文弹出调用栈）</p><p>只在严格模式开启</p><h2 id="_3-8-常见的问题" tabindex="-1">3.8 常见的问题 <a class="header-anchor" href="#_3-8-常见的问题" aria-label="Permalink to &quot;3.8 常见的问题&quot;">​</a></h2>',34),s=[l];function n(c,h,_,d,u,b){return e(),t("div",null,s)}const g=a(p,[["render",n]]);export{f as __pageData,g as default};
