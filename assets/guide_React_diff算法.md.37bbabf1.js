import{_ as e,o as a,c as t,Q as d}from"./chunks/framework.b6910bb2.js";const m=JSON.parse('{"title":"单节点diff算法 （render方法创建的element元素子节点只有一个）","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/diff算法.md","filePath":"guide/React/diff算法.md","lastUpdated":1702286381000}'),i={name:"guide/React/diff算法.md"},n=d('<h1 id="单节点diff算法-render方法创建的element元素子节点只有一个" tabindex="-1">单节点diff算法 （render方法创建的element元素子节点只有一个） <a class="header-anchor" href="#单节点diff算法-render方法创建的element元素子节点只有一个" aria-label="Permalink to &quot;单节点diff算法 （render方法创建的element元素子节点只有一个）&quot;">​</a></h1><h2 id="_1-旧节点不存在" tabindex="-1">1. 旧节点不存在 <a class="header-anchor" href="#_1-旧节点不存在" aria-label="Permalink to &quot;1. 旧节点不存在&quot;">​</a></h2><ol><li>如果旧节点不存在，则直接新增节点</li></ol><h2 id="_2-旧节点存在" tabindex="-1">2. 旧节点存在 <a class="header-anchor" href="#_2-旧节点存在" aria-label="Permalink to &quot;2. 旧节点存在&quot;">​</a></h2><p>1 判断 key 和 tag 是否相同，相同则复用节点，更新属性 2 如果 key 相同但 tag 不相同，则删除所有节点 3 如果 key、tag 不同，则不需要复用，旧节点标记为删除</p><h1 id="多节点diff算法-render方法创建的element元素子节点有多个" tabindex="-1">多节点diff算法 （render方法创建的element元素子节点有多个） <a class="header-anchor" href="#多节点diff算法-render方法创建的element元素子节点有多个" aria-label="Permalink to &quot;多节点diff算法 （render方法创建的element元素子节点有多个）&quot;">​</a></h1><p>多节点diff有双层 for 循环, 第一层 for 循环判断元素是否需要更新，第二层 for 循环判断元素是否需要移动位置</p><h2 id="_1-第一层-for-循环比较key和tag-如果相同则复用-并用-lastindex-标记当前可以复用的节点位置" tabindex="-1">1 第一层 for 循环比较key和tag, 如果相同则复用, 并用 lastIndex 标记当前可以复用的节点位置 <a class="header-anchor" href="#_1-第一层-for-循环比较key和tag-如果相同则复用-并用-lastindex-标记当前可以复用的节点位置" aria-label="Permalink to &quot;1 第一层 for 循环比较key和tag, 如果相同则复用, 并用 lastIndex 标记当前可以复用的节点位置&quot;">​</a></h2><h2 id="_2-遇到不相同时-跳出第一层-for-循环-创建一个-map-对象-存储旧节点的-key-和-index-有点类似于找最长公共子序列" tabindex="-1">2 遇到不相同时, 跳出第一层 for 循环, 创建一个 Map 对象, 存储旧节点的 key 和 index - 有点类似于找最长公共子序列 <a class="header-anchor" href="#_2-遇到不相同时-跳出第一层-for-循环-创建一个-map-对象-存储旧节点的-key-和-index-有点类似于找最长公共子序列" aria-label="Permalink to &quot;2 遇到不相同时, 跳出第一层 for 循环, 创建一个 Map 对象, 存储旧节点的 key 和 index - 有点类似于找最长公共子序列&quot;">​</a></h2><ul><li>key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束</li><li>key 相同 type 不同导致不可复用，会将 oldFiber 标记为 DELETION，并继续遍历</li></ul><h2 id="_3-在-map-对象中查找新节点的-key-如果存在-则说明新节点可以复用旧节点-并且判断是否需要移动位置" tabindex="-1">3 在 Map 对象中查找新节点的 key, 如果存在, 则说明新节点可以复用旧节点, 并且判断是否需要移动位置 <a class="header-anchor" href="#_3-在-map-对象中查找新节点的-key-如果存在-则说明新节点可以复用旧节点-并且判断是否需要移动位置" aria-label="Permalink to &quot;3 在 Map 对象中查找新节点的 key, 如果存在, 则说明新节点可以复用旧节点, 并且判断是否需要移动位置&quot;">​</a></h2><h2 id="_4-如果-index-lastindex-则不需要移动位置-更新-lastindex" tabindex="-1">4 如果 index &gt; lastIndex, 则不需要移动位置, 更新 lastIndex <a class="header-anchor" href="#_4-如果-index-lastindex-则不需要移动位置-更新-lastindex" aria-label="Permalink to &quot;4 如果 index &gt; lastIndex, 则不需要移动位置, 更新 lastIndex&quot;">​</a></h2><h2 id="_5-如果-index-lastindex-则需要移动位置-不需要更新-lastindex" tabindex="-1">5 如果 index &lt; lastIndex, 则需要移动位置, 不需要更新 lastIndex <a class="header-anchor" href="#_5-如果-index-lastindex-则需要移动位置-不需要更新-lastindex" aria-label="Permalink to &quot;5 如果 index &lt; lastIndex, 则需要移动位置, 不需要更新 lastIndex&quot;">​</a></h2>',13),r=[n];function l(o,s,f,h,x,_){return a(),t("div",null,r)}const k=e(i,[["render",l]]);export{m as __pageData,k as default};
