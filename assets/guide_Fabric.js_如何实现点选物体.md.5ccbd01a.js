import{_ as t,o as e,c as a,Q as r}from"./chunks/framework.b6910bb2.js";const o="/vitePress-blob/assets/1.4d5a2b6a.gif",i="/vitePress-blob/assets/image-3.bc73d938.png",s="/vitePress-blob/assets/2.05638152.gif",l="/vitePress-blob/assets/image-4.7e66fc23.png",p="/vitePress-blob/assets/image-5.c2db871f.png",q=JSON.parse('{"title":"如何实现点选物体","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Fabric.js/如何实现点选物体.md","filePath":"guide/Fabric.js/如何实现点选物体.md","lastUpdated":1736861630000}'),d={name:"guide/Fabric.js/如何实现点选物体.md"},n=r('<h1 id="如何实现点选物体" tabindex="-1">如何实现点选物体 <a class="header-anchor" href="#如何实现点选物体" aria-label="Permalink to &quot;如何实现点选物体&quot;">​</a></h1><p>上一节，我们了解了在 Fabric.js 中，可以通过 <code>transform</code> 进行矩阵运算，从而达到平移、旋转、缩放的目的。</p><p>接下来我们将了解如何对一个物体进行点选，在 Fabric.js 的表现即鼠标移动到元素上，呈现hover状态，移出则显示默认状态。</p><p><img src="'+o+'" alt="点选效果"></p><h2 id="判断是否在矩形内部" tabindex="-1">判断是否在矩形内部 <a class="header-anchor" href="#判断是否在矩形内部" aria-label="Permalink to &quot;判断是否在矩形内部&quot;">​</a></h2><p>如果对于矩形元素来说, 我们可以获取到四个顶点的坐标，进而判断当前的鼠标坐标是否在顶点坐标之内即可。</p><p>例如矩形的左上角顶点坐标是 left、top</p><p>那么我们只需要判断 <code>left &lt;= x &lt;= left + width &amp;&amp; top &lt;= y &lt;= top + height</code> 即可。</p><p>基于此，在 Fabric.js 静态层 Canvas 会有一个 <code>_objects</code> 数组，存储了所有图形的数据，</p><p>此时可以通过从后往前遍历（因为最后添加元素位于数组最后）判断鼠标点是否在元素上。</p><h2 id="包围盒" tabindex="-1">包围盒 <a class="header-anchor" href="#包围盒" aria-label="Permalink to &quot;包围盒&quot;">​</a></h2><p>对于其他图形，例如三角形等，可以引入包围盒的概念，将其他图形转化为矩形进行判断。</p><p>常见的有 OBB、AABB、球模型包围盒</p><p><img src="'+i+'" alt="alt text"></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>AABB（轴对齐包围盒）</strong></td><td>边与坐标轴对齐，由最小点和最大点定义</td><td>计算简单，存储效率高</td><td>对旋转物体可能不紧凑，浪费空间</td><td>静态场景筛选，粗略碰撞检测</td></tr><tr><td><strong>OBB（方向包围盒）</strong></td><td>可任意旋转，由中心点、尺寸向量和旋转矩阵描述</td><td>更紧凑地包围旋转物体</td><td>计算复杂度高</td><td>精确碰撞检测，动态物体包围</td></tr><tr><td><strong>球模型包围盒</strong></td><td>以中心点和半径定义</td><td>旋转无影响，检测简单</td><td>对非球状物体浪费较多空间</td><td>初步碰撞检测，三维场景快速筛选</td></tr></tbody></table><p><img src="'+s+'" alt="alt text"></p><p>我们不难发现，在 Fabric.js 中也是通过 AABB 包围盒进行点选物体的。</p><p>演示地址: <a href="https://enson0131.github.io/mini-fabric-whiteboard/" target="_blank" rel="noreferrer">https://enson0131.github.io/mini-fabric-whiteboard/</a></p><h2 id="点射法" tabindex="-1">点射法 <a class="header-anchor" href="#点射法" aria-label="Permalink to &quot;点射法&quot;">​</a></h2><p>对于矩形，我们可以很方便地计算出点是否在矩形内，在不借助包围盒的情况下，是否可以判断点在多边形内呢？</p><p>显然是可以的，常见的算法是 <code>点射法</code>，这种方法的核心思想是通过从待测点发射一条射线（通常是直线或半直线），然后统计射线与几何区域的边或面相交的次数。</p><ol><li><p>如果射线与边/面的交点数是奇数，点在多边形内部。</p></li><li><p>如果交点数是偶数，点在多边形外部。</p></li></ol><p>大致可以在脑海里想象下👇</p><p><img src="'+l+'" alt="alt text"></p><p>应该有不少同学已经想象到一些边界场景：</p><ol><li><p>点在多边形的顶点上</p></li><li><p>点所在的射线穿过图形的顶点上</p></li><li><p>点的射线穿过图形的一条边</p></li></ol><p><img src="'+p+'" alt="alt text"></p><p>基于第一种场景，可以通过业务场景决定是否在多边形内/外。</p><p>基于二三中场景，通常会判断这条射线的两侧是否有图形的边，若有则为基数，若无则为偶数。</p><p>这里以一种数学极限的方式去判断，例如做一条无限逼近的射线，判断点数。</p><h2 id="点在多边形内的其他方法" tabindex="-1">点在多边形内的其他方法 <a class="header-anchor" href="#点在多边形内的其他方法" aria-label="Permalink to &quot;点在多边形内的其他方法&quot;">​</a></h2><ol><li><p>用 canvas 自身的 api isPointInPath</p></li><li><p>将多边形切割成多个三角形，然后判断点是否在某个三角形内部</p></li><li><p>转角累加法（点连接各个顶点，计算夹角是否等于 360）</p></li><li><p>面积法 （点连接各个顶点形成三角形，计算面积是否等于图形的面积等）</p></li></ol><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p>1 记录最近的这个物体，下次再次判断这个物体。 2 判断是否是透明区域</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection</a></li><li><a href="https://kenshin.tech/page/2/" target="_blank" rel="noreferrer">https://kenshin.tech/page/2/</a></li></ul>',36),h=[n];function c(_,b,g,m,f,u){return e(),a("div",null,h)}const x=t(d,[["render",c]]);export{q as __pageData,x as default};
