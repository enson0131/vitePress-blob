import{_ as e,o as r,c as o,Q as t}from"./chunks/framework.b6910bb2.js";const a="/vitePress-blob/assets/3.9b1f9060.png",i="/vitePress-blob/assets/4.f4dd49d0.png",n="/vitePress-blob/assets/5.34ee565e.png",s="/vitePress-blob/assets/12.ba19c2aa.png",c="/vitePress-blob/assets/6.121ea6f5.png",l="/vitePress-blob/assets/7.3f678f52.png",p="/vitePress-blob/assets/8.9d04f238.png",d="/vitePress-blob/assets/9.bae86652.png",b="/vitePress-blob/assets/11.07a5666c.png",h="/vitePress-blob/assets/13.5bf5bc75.png",m="/vitePress-blob/assets/14.f1d70f78.png",u="/vitePress-blob/assets/16.4d6f740b.png",_="/vitePress-blob/assets/15.254fe341.png",f="/vitePress-blob/assets/18.09fcc54c.png",k="/vitePress-blob/assets/17.625ac807.png",g="/vitePress-blob/assets/19.77c3b0a6.png",C=JSON.parse('{"title":"React 是如何渲染的","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/React是如何渲染的.md","filePath":"guide/React/React是如何渲染的.md","lastUpdated":1717753108000}'),R={name:"guide/React/React是如何渲染的.md"},P=t('<h1 id="react-是如何渲染的" tabindex="-1">React 是如何渲染的 <a class="header-anchor" href="#react-是如何渲染的" aria-label="Permalink to &quot;React 是如何渲染的&quot;">​</a></h1><h2 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h2><p>React 的渲染过程可以分成 2 大阶段, 分别是调和阶段和提交阶段。 调和阶段可以分成 beginWork 阶段、 completeWork 阶段。 在 beginWork 阶段中，React 会根据新生成的 ReactElement 对象和旧的 Fiber 节点进行对比，判断是否可以复用旧的 Fiber 节点并对 Fiber 进行标记。 在 completeWork 节点中，会自底向上构建副作用链表，用来记录需要更新的节点，生成的 DOM 节点会挂载在 Fiber 的 stateNode 属性上。</p><p>提交阶段主要分成：操作 DOM 前阶段、操作 DOM 阶段、操作 DOM 后阶段。</p><h2 id="react-16-以前" tabindex="-1">React 16 以前 <a class="header-anchor" href="#react-16-以前" aria-label="Permalink to &quot;React 16 以前&quot;">​</a></h2><p>在浏览器中 js 线程与渲染线程是互斥的，如果 js 线程长期占用着浏览器的主线程，那么界面将长时间不更新，在动画等一些场景下会造成卡顿效果。</p><p>因为 Stack Reconciler 是一个同步的递归过程，随着业务复杂度增加，Stack Reconciler 需要的调和时间会变长，</p><p>这意味着 js 将长时间占用浏览器，进而导致页面卡顿</p><p><img src="'+a+'" alt="Stack Reconciler"></p><h2 id="react-16-以后" tabindex="-1">React 16 以后 <a class="header-anchor" href="#react-16-以后" aria-label="Permalink to &quot;React 16 以后&quot;">​</a></h2><p>将同步执行的 Stack Reconciler 替换成了异步可中断的 Fiber Reconciler</p><p><img src="'+i+'" alt="Fiber Reconciler"></p><p>在更新时，每个任务会被赋予一个优先级，当任务抵达调度器时，高优先级的任务会更快抵达协调器，如有新的更高优先级的任务进入调度器时，当前协调器的任务就会被中断，更高优先级的任务将进入 reconciler</p><p><img src="'+n+'" alt="Fiber Reconciler"></p><p>新的架构会导致部分生命周期重复执行:</p><ul><li>componentWillMount</li><li>componentWillUpdate</li><li>showComponentUpdate</li><li>componentWillReceiveProps</li></ul><p><img src="'+s+'" alt="Render Performance"></p><p>从首次渲染的调用栈来看，React 的渲染过程主要分为以下几个步骤:</p><ul><li><ol><li>Mount 阶段</li></ol></li><li><ol start="2"><li>Render 阶段</li></ol></li><li><ol start="3"><li>Commit 阶段</li></ol></li></ul><h2 id="mount-阶段" tabindex="-1">Mount 阶段 <a class="header-anchor" href="#mount-阶段" aria-label="Permalink to &quot;Mount 阶段&quot;">​</a></h2><p>当执行 ReactDOM.render 时会直接调用 <code>legacyRenderSubtreeIntoContainer</code> 方法</p><h3 id="legacyrendersubtreeintocontainer-方法" tabindex="-1">legacyRenderSubtreeIntoContainer 方法 <a class="header-anchor" href="#legacyrendersubtreeintocontainer-方法" aria-label="Permalink to &quot;legacyRenderSubtreeIntoContainer 方法&quot;">​</a></h3><p>会创建 reactRootContainer 对象（也就是挂载的容器对象）, reactRootContainer 对象的 _internalRoot 会指向 fiberRoot (FiberRootNode 类)，也就是根节点对象。</p><p><code>legacyRenderSubtreeIntoContainer</code> 最终返回挂载组件( App组件 )的实例对象。</p><p><img src="'+c+'" alt="Mount 渲染过程"></p><p><img src="'+l+'" alt="FiberRootNode对象的描述"></p><p>在 fiberRoot 对象（ FiberRootNode类 ）中的 current 属性将指向 rootFiber 对象 （根节点Fiber，即 FiberNode 实例）</p><p><img src="'+p+'" alt="fiberRoot对象指向 rootFiber 根节点Fiber"></p><p><img src="'+d+'" alt="挂载创建关系图"></p><h3 id="updatecontainer-函数" tabindex="-1">updateContainer 函数 <a class="header-anchor" href="#updatecontainer-函数" aria-label="Permalink to &quot;updateContainer 函数&quot;">​</a></h3><p>updateContainer 函数主要有以下 3 件事:</p><ul><li><ol><li>获取当前节点的优先级 lane</li></ol></li><li><ol start="2"><li>结合 lane 创建当前 Fiber 节点 update 对象，并将其入队</li></ol></li><li><ol start="3"><li>调度当前节点 (rootFiber 节点)</li></ol></li></ul><p><img src="'+b+'" alt="updateContainer"></p><h3 id="scheduleupdateonfiber-函数" tabindex="-1">scheduleUpdateOnFiber 函数 <a class="header-anchor" href="#scheduleupdateonfiber-函数" aria-label="Permalink to &quot;scheduleUpdateOnFiber 函数&quot;">​</a></h3><p>scheduleUpdateOnFiber 函数中会获取 Fiber 节点的mode属性判断是否走同步渲染还是异步渲染的逻辑，在 React17 中首次渲染走的是同步渲染的逻辑</p><p><img src="'+h+'" alt="scheduleUpdateOnFiber"></p><p>这里可能有小伙伴会问，Fiber架构不就是异步渲染的么？ 我想说的是，Fiber架构的设计初衷确实是为了异步渲染而设计的，但是 Fiber 架构并不能和异步渲染画上等号，我们不难发现，Fiber 架构同时兼容了同步渲染和异步渲染，如下图，决定同步还是异步取决于 mode</p><p><img src="'+m+'" alt="mode 决定同步异步"></p><h2 id="render-阶段" tabindex="-1">Render 阶段 <a class="header-anchor" href="#render-阶段" aria-label="Permalink to &quot;Render 阶段&quot;">​</a></h2><h3 id="performsyncworkonroot-函数" tabindex="-1">performSyncWorkOnRoot 函数 <a class="header-anchor" href="#performsyncworkonroot-函数" aria-label="Permalink to &quot;performSyncWorkOnRoot 函数&quot;">​</a></h3><p>核心逻辑在 <code>renderRootSync</code> 函数中</p><h3 id="renderrootsync-函数" tabindex="-1">renderRootSync 函数 <a class="header-anchor" href="#renderrootsync-函数" aria-label="Permalink to &quot;renderRootSync 函数&quot;">​</a></h3><p>核心方法有俩个 <code>prepareFreshStack</code> 和 <code>workLoopSync</code> 函数</p><p><img src="'+u+'" alt="renderRootSync 逻辑"></p><h3 id="preparefreshstack-函数" tabindex="-1">prepareFreshStack 函数 <a class="header-anchor" href="#preparefreshstack-函数" aria-label="Permalink to &quot;prepareFreshStack 函数&quot;">​</a></h3><p>主要是有个方法 <code>createWorkInProgress</code> , 用来构建 workInProgress 双缓冲树，通过 <code>alternate</code> 相互指向</p><p><img src="'+_+'" alt="createWorkInProgress 构建 work-in-progress 树"></p><p>当建立好双缓冲树的关系后，我们不难得到以下的关系图</p><p><img src="'+f+'" alt="双缓冲树关系图"></p><h3 id="workloopsync-函数" tabindex="-1">workLoopSync 函数 <a class="header-anchor" href="#workloopsync-函数" aria-label="Permalink to &quot;workLoopSync 函数&quot;">​</a></h3><p>当我们构建完 workInProgress Tree 的根节点时，建立 current tree 和 workInProgess Tree 的关联关系后，将进入 workLoopSync 调和阶段。</p><p>反复判断 workInProgress 是否为空，如果不为空，就执行 performUnitOfWork 方法 <img src="'+k+'" alt="workLoopSync 逻辑"></p><h3 id="performunitofwork-函数" tabindex="-1">performUnitOfWork 函数 <a class="header-anchor" href="#performunitofwork-函数" aria-label="Permalink to &quot;performUnitOfWork 函数&quot;">​</a></h3><p>performUnitOfWork 函数的作用是 beginWork 优先创建子节点。 completeUnitOfWork 创建完子节点后判断是否有兄弟节点，有则创建兄弟节点，无则继续向上遍历父节点，直到遍历到根节点为止</p><p><img src="'+g+'" alt="performUnitOfWork 逻辑"></p><h4 id="beginwork-函数" tabindex="-1">beginWork 函数 <a class="header-anchor" href="#beginwork-函数" aria-label="Permalink to &quot;beginWork 函数&quot;">​</a></h4><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><p>1 <a href="https://zhuanlan.zhihu.com/p/385319664" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/385319664</a> 2</p>',58),q=[P];function F(S,y,W,v,w,x){return r(),o("div",null,q)}const U=e(R,[["render",F]]);export{C as __pageData,U as default};
