import{_ as e,o as t,c as o,Q as c}from"./chunks/framework.b6910bb2.js";const f=JSON.parse('{"title":"对 Fiber 的理解","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/什么是Fiber.md","filePath":"guide/React/什么是Fiber.md","lastUpdated":1709084980000}'),r={name:"guide/React/什么是Fiber.md"},a=c('<h1 id="对-fiber-的理解" tabindex="-1">对 Fiber 的理解 <a class="header-anchor" href="#对-fiber-的理解" aria-label="Permalink to &quot;对 Fiber 的理解&quot;">​</a></h1><p>在 React 15 中通过 <code>递归</code> 的形式进行对比，找到需要更新的节点，并同步更新它，在这段时间一直占据着浏览器主线程，可能会给用户带来卡顿的感受（在渲染进程中，<code>js线程和渲染线程是互斥的</code>）</p><p>在 React 15 以后引入了 Fiber 架构，将对比的过程变成了<code>异步可中断</code>的过程，让出浏览器的使用权，让浏览器处理更高优先级的事情</p><p>Fiber 的调和过程（Reconciler）由分成了 <code>beginWork</code> 阶段 和 <code>completeUnitOfWork</code> 阶段。</p><p><code>beginWork</code> 阶段自顶向下，根据当前工作的 Fiber 节点最新的 React Element 子元素与旧 Fiber 节点进行对比，决定是否需要复用旧 Fiber 节点并标记 Fiber 节点是否有副作用。</p><p><code>compeleteUnitOfWork</code> 阶段自底向上构建副作用链表，生成的 DOM 节点挂在 Fiber 的 stateNode 属性</p>',6),i=[a];function d(_,n,s,p,b,l){return t(),o("div",null,i)}const m=e(r,[["render",d]]);export{f as __pageData,m as default};
