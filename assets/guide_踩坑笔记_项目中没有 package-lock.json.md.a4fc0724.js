import{_ as a,o as e,c as o,Q as s}from"./chunks/framework.b6910bb2.js";const l="/vitePress-blob/assets/5.c6172d6e.png",n="/vitePress-blob/assets/1.3c7c9109.png",p="/vitePress-blob/assets/2.07f8e026.png",c="/vitePress-blob/assets/3.845100c9.png",t="/vitePress-blob/assets/4.8924fecd.png",i="/vitePress-blob/assets/6.c26600f5.png",y=JSON.parse('{"title":"从 node_modules 逆向生成 package-lock.json 的救火实战","description":"","frontmatter":{},"headers":[],"relativePath":"guide/踩坑笔记/项目中没有 package-lock.json.md","filePath":"guide/踩坑笔记/项目中没有 package-lock.json.md","lastUpdated":1751878210000}'),d={name:"guide/踩坑笔记/项目中没有 package-lock.json.md"},r=s('<h1 id="从-node-modules-逆向生成-package-lock-json-的救火实战" tabindex="-1">从 node_modules 逆向生成 package-lock.json 的救火实战 <a class="header-anchor" href="#从-node-modules-逆向生成-package-lock-json-的救火实战" aria-label="Permalink to &quot;从 node_modules 逆向生成 package-lock.json 的救火实战&quot;">​</a></h1><p><img src="'+l+'" alt="踩坑笔记"></p><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>在风和日丽的下午，小C 正在愉快的敲着代码，突然接到一个任务，说需要紧急开发一个介绍文件的下载页面，并部署到线上。</p><p>小C 询问了项目仓库地址，娴熟地拉下了代码，准备重新安装依赖时，发现项目中没有 package-lock.json 文件（心态崩了，因为这个项目 4 年前维护的，package-lock.json 文件早就被删除了，无法追溯😭）。</p><p>因开发时间有限，小C 需要尽快解决这个安装依赖问题，否则会影响到项目进度。</p><h2 id="问题分析🤔" tabindex="-1">问题分析🤔 <a class="header-anchor" href="#问题分析🤔" aria-label="Permalink to &quot;问题分析🤔&quot;">​</a></h2><h3 id="为什么需要-package-lock-json-文件" tabindex="-1">为什么需要 package-lock.json 文件？ <a class="header-anchor" href="#为什么需要-package-lock-json-文件" aria-label="Permalink to &quot;为什么需要 package-lock.json 文件？&quot;">​</a></h3><p>在了解 package-lock.json 文件之前，先了解一下 package.json 文件，如下图所示：</p><p><img src="'+n+'" alt="踩坑笔记"></p><p>在 package.json 中，依赖的版本号存在大版本、小版本、补丁版本</p><ul><li>大版本：表示主版本号，表示重大更新，可能不兼容旧版本</li><li>次版本: 表示次版本号，表示次要更新，可能兼容旧版本</li><li>补丁版本：表示修订号，表示 bug 修复，可能兼容旧版本</li></ul><p><img src="'+p+'" alt="踩坑笔记"></p><p>而 <code>~</code> 表示 npm install 会安装符合补丁版本的最新版本, 例如，~1.2.3会允许安装1.2.4，但不允许1.3.0 <code>^</code> 会更加灵活一些，表示 npm install 会安装符合次版本号的最新版本, 例如，^1.2.3可以安装1.3.0，但不包括2.0.0</p><p>同归问题，当小 A 和小 C 在不同的时间安装依赖时，可能会出现不同的依赖版本，从而导致项目无法正常运行。</p><p><img src="'+c+`" alt="踩坑笔记"></p><p>因此，为了保证在不同的时间安装依赖时，依赖版本的一致性，需要使用 package-lock.json 文件。</p><h3 id="回归业务场景" tabindex="-1">回归业务场景 <a class="header-anchor" href="#回归业务场景" aria-label="Permalink to &quot;回归业务场景&quot;">​</a></h3><p>目前这个 4 年前项目中没有 package-lock.json 文件，如果随意安装最新的版本，可能导致版本不一致，无法确保项目正常稳定地运行。</p><p>在焦头烂额之际，小C 突然发现生产环境的容器里面存在 node_modules 文件夹，并确认了构建时的 Node 版本。</p><p>小C 灵机一动，如果从生产环境的容器里面拷贝 node_modules 文件夹，基于 node_modules 生成 package-lock.json 文件，是否可以解决这个问题呢？</p><p>小C 说干就干，拷贝了 node_modules 文件夹，并安装了依赖，项目成功运行了。</p><h3 id="通过-node-modules-文件生成-package-lock-json" tabindex="-1">通过 node_modules 文件生成 package-lock.json <a class="header-anchor" href="#通过-node-modules-文件生成-package-lock-json" aria-label="Permalink to &quot;通过 node_modules 文件生成 package-lock.json&quot;">​</a></h3><h4 id="生成初始-lock-文件" tabindex="-1">生成初始 lock 文件 <a class="header-anchor" href="#生成初始-lock-文件" aria-label="Permalink to &quot;生成初始 lock 文件&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">npm</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">install</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--package-lock-only</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--offline</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">#// --package-lock-only：不修改 node_modules</span></span>
<span class="line"><span style="color:#6A737D;">#// --offline：离线安装</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">npm</span><span style="color:#24292E;"> </span><span style="color:#032F62;">install</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--package-lock-only</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--offline</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">#// --package-lock-only：不修改 node_modules</span></span>
<span class="line"><span style="color:#6A737D;">#// --offline：离线安装</span></span></code></pre></div><p>最后将 package-lock.json 文件放入版本控制。</p><h4 id="生成-lock-文件的原理" tabindex="-1">生成 lock 文件的原理 <a class="header-anchor" href="#生成-lock-文件的原理" aria-label="Permalink to &quot;生成 lock 文件的原理&quot;">​</a></h4><p><img src="`+t+'" alt="踩坑笔记"></p><p>在执行 npm install 的过程如下</p><ol><li><p>初始条件判断</p><ul><li>存在 package-lock.json</li><li>不存在 package-lock.json</li></ul></li><li><p>依赖解析阶段 npm 会递归分析每个依赖包的 dependencies、devDependencies 和 peerDependencies，形成完整的依赖树。</p></li><li><p>缓存检查与下载</p><ul><li>检查缓存中是否存在该依赖</li><li>如果存在，则直接使用缓存中的依赖</li><li>如果不存在，则从 npm 仓库下载依赖</li><li>下载的依赖会存储在缓存中，方便下次使用</li></ul></li><li><p>node_modules 构建</p><ul><li>根据依赖树，构建 node_modules 目录结构</li></ul></li><li><p>lock 文件生成/更新</p></li></ol><p>归回业务场景，小C 拷贝了生产环境的 node_modules 文件夹，在执行 npm install 时，因存在缓存包，复用了 node_modules 文件夹，进而生成了和生产环境依赖版本一致的 package-lock.json 文件，确保了项目正常运行。</p><p><img src="'+i+'" alt="踩坑笔记"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在没有 package-lock.json 文件的情况下，在确保 Node 版本一致的情况下，可以通过执行 <code>npm install --package-lock-only --offline</code> 命令，基于 node_modules 文件夹，生成 package-lock.json 文件，确保项目正常运行。</p>',34),k=[r];function _(g,h,m,u,b,j){return e(),o("div",null,k)}const P=a(d,[["render",_]]);export{y as __pageData,P as default};
