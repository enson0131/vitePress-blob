import{_ as a,o as e,c as s,Q as t}from"./chunks/framework.b6910bb2.js";const l="/vitePress-blob/assets/13.ebfa1a54.png",r="/vitePress-blob/assets/14.92ddec45.png",m=JSON.parse('{"title":"可视区域内渲染提高 Canvas 的书写性能","description":"","frontmatter":{},"headers":[],"relativePath":"guide/canvas/可视区域内渲染提高Canvas书写性能.md","filePath":"guide/canvas/可视区域内渲染提高Canvas书写性能.md","lastUpdated":1703159155000}'),o={name:"guide/canvas/可视区域内渲染提高Canvas书写性能.md"},n=t('<h1 id="可视区域内渲染提高-canvas-的书写性能" tabindex="-1">可视区域内渲染提高 Canvas 的书写性能 <a class="header-anchor" href="#可视区域内渲染提高-canvas-的书写性能" aria-label="Permalink to &quot;可视区域内渲染提高 Canvas 的书写性能&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>上一节我们通过离屏渲染提高了 Canvas 的渲染性能，但是离屏渲染也有一些缺点，比如会增加内存的使用，而且在某些场景下，离屏渲染的性能并不会比直接在 Canvas 上绘制要高。本节我们将介绍如何通过可视区域内渲染提高 Canvas 的书写性能。</p><h2 id="前提" tabindex="-1">前提 <a class="header-anchor" href="#前提" aria-label="Permalink to &quot;前提&quot;">​</a></h2><p>一般我们说的可视区域内渲染，是指在 Canvas 上只绘制可视区域内的内容，而不是绘制整个 Canvas 的内容。这样做的好处是可以减少 Canvas 的绘制区域，从而提高 Canvas 的渲染性能。</p><p>对于 Canvas 而言，无法无限制地扩大 Canvas 的面积，因此浏览器对 Canvas 的大小也有一定的限制。从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas#%E6%9C%80%E5%A4%A7%E7%9A%84%E7%94%BB%E5%B8%83%E5%B0%BA%E5%AF%B8" target="_blank" rel="noreferrer">MDN 文档</a> 可知, 在 Chrome 浏览器中，Canvas 的大小限制为 32767px * 32767px。由于 Canvas 的大小限制，因此我们在实现 <code>无限画布</code> 的功能时，不能无限的拓展 Canvas 的大小，而应该通过坐标的切换，来实现无限画布的功能。</p><h2 id="实现无限画布" tabindex="-1">实现无限画布 <a class="header-anchor" href="#实现无限画布" aria-label="Permalink to &quot;实现无限画布&quot;">​</a></h2><h3 id="实现思路" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路" aria-label="Permalink to &quot;实现思路&quot;">​</a></h3><p>记初始坐标A (x, y), 横向滚动距离为 scrollX, 纵向滚动距离为 scrollY</p><p>在初始状态下, scrollX、scrollY 均为 0</p><p><img src="'+l+'" alt="初始状态图"></p><p>假设现在，我们在水平方向向右滚动了scrollX，垂直方向向下滚动scrollY。那么滚动后的坐标就是</p><p>x1 = x - scrollX</p><p>y1 = y - scrollY</p><p>这里大家可能会有疑惑，为什么是减法呢？因为向下滚动后，绘制的图形应该是往上移动的，因此我们需要减去滚动的距离。</p><p><img src="'+r+'" alt="滚动后的状态图"></p><h3 id="具体实现" tabindex="-1">具体实现 <a class="header-anchor" href="#具体实现" aria-label="Permalink to &quot;具体实现&quot;">​</a></h3><p>WheelEvent 事件能够监听鼠标滚动。其中的 WheelEvent.deltaX 记录了横向滚动量（也就是我们上面说到的 scrollX），WheelEvent.deltaY 记录了纵向滚动量 （上面说的 scrollY）</p><p>我们可以在 Canvas 上监听 WheelEvent 事件，然后根据 WheelEvent.deltaX 和 WheelEvent.deltaY 来计算出滚动后的坐标，从而实现无限画布的功能。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span></code></pre></div><h3 id="实现效果" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><h2 id="可视区域内渲染" tabindex="-1">可视区域内渲染 <a class="header-anchor" href="#可视区域内渲染" aria-label="Permalink to &quot;可视区域内渲染&quot;">​</a></h2><h3 id="实现思路-1" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路-1" aria-label="Permalink to &quot;实现思路&quot;">​</a></h3><h3 id="具体效果" tabindex="-1">具体效果 <a class="header-anchor" href="#具体效果" aria-label="Permalink to &quot;具体效果&quot;">​</a></h3><h3 id="实现效果-1" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果-1" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas#%E6%9C%80%E5%A4%A7%E7%9A%84%E7%94%BB%E5%B8%83%E5%B0%BA%E5%AF%B8" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas#最大的画布尺寸</a></li></ul>',27),i=[n];function h(c,d,p,v,_,u){return e(),s("div",null,i)}const C=a(o,[["render",h]]);export{m as __pageData,C as default};
