import{_ as i,o,c as l,Q as e}from"./chunks/framework.b6910bb2.js";const a="/vitePress-blob/assets/7.d0aefc74.jpg",t="/vitePress-blob/assets/8.28d1dcd9.jpg",s="/vitePress-blob/assets/16.ecfc65d2.jpg",r="/vitePress-blob/assets/17.8329667f.jpg",n="/vitePress-blob/assets/18.5204f2f6.jpg",q=JSON.parse('{"title":"跨域请求","description":"","frontmatter":{},"headers":[],"relativePath":"guide/网络相关/跨域请求.md","filePath":"guide/网络相关/跨域请求.md","lastUpdated":1707037419000}'),c={name:"guide/网络相关/跨域请求.md"},d=e('<h1 id="跨域请求" tabindex="-1">跨域请求 <a class="header-anchor" href="#跨域请求" aria-label="Permalink to &quot;跨域请求&quot;">​</a></h1><h2 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-label="Permalink to &quot;简单请求&quot;">​</a></h2><p>若请求满足<strong>所有</strong>下述条件，则该请求可视为简单请求：</p><ol><li>HEAD/GET/POST 请求</li><li>Content-Type: text/plain、multipart/form-data、application/x-www-form-urlencoded</li><li>除了被用户代理自动设置的标头字段，剩下的请求头是: Accept、Accept-Language、Content-Language、Content-Type、Range</li></ol><h3 id="请求过程" tabindex="-1">请求过程 <a class="header-anchor" href="#请求过程" aria-label="Permalink to &quot;请求过程&quot;">​</a></h3><ol><li>发起请求，请求头会带上 Origin 字段，该字段用来说明请求来自哪个源（协议 + 域名 + 端口），服务器根据这个值决定是否同意这次请求</li><li>当服务器接收到请求后，根据 Origin 判断是否在允许的范围内</li><li>如果不在范围内，服务器会返回一个正常的 HTTP 响应，浏览器发现响应头信息没有 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出错误，被 XML 的 onerror 回调函数捕获。（注意：由于正常响应，其状态码为200，因此该错误不能通过状态码识别）</li><li>如果 Origin 指定的域名在范围内，服务器返回的响应会多出几个头信息字段（Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Header 等）</li></ol><p><img src="'+a+'" alt="流程"></p><h2 id="非简单请求" tabindex="-1">非简单请求 <a class="header-anchor" href="#非简单请求" aria-label="Permalink to &quot;非简单请求&quot;">​</a></h2><p>请求方法是 PUT、DELETE 或者 Content-Type 是 application/json 类型</p><h3 id="请求过程-源、请求头、方法、缓存、cookie" tabindex="-1">请求过程 （源、请求头、方法、缓存、Cookie） <a class="header-anchor" href="#请求过程-源、请求头、方法、缓存、cookie" aria-label="Permalink to &quot;请求过程 （源、请求头、方法、缓存、Cookie）&quot;">​</a></h3><ol><li>浏览器发起 Option 预检请求</li><li>服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段后，确认允许跨域请求，就可以做出回应 <ul><li>Origin (必须): 发起请求的源信息</li><li>Access-Control-Request-Method（必须）: 用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法</li><li>Access-Control-Request-Headers 跨域请求而外的请求头字段</li></ul></li><li>如果服务器预检请求，会返回一个正常的 HTTP 回应，但没有任何的 CORS 相关的头信息字段，这时浏览器就会认定服务器不同意预检请求，触发错误。</li><li>如果服务器通过了预检请求，以后每次浏览器正常的 CORS 请求就跟简单请求一样 <ul><li>Access-Control-Allow-Origin（必须）: 运行哪些源跨域，如果是 * 无法携带 Cookie</li><li>Access-Control-Allow-Method（必须）: 服务器支持哪些请求</li><li>Access-Control-Allow-Header: 服务器支持的头信息字段</li><li>Access-Control-Max-Age: 预检请求的有效期，单位秒</li></ul></li></ol><p><img src="'+t+'" alt="流程"></p><h2 id="跨域请求如何传输-cookie" tabindex="-1">跨域请求如何传输 cookie <a class="header-anchor" href="#跨域请求如何传输-cookie" aria-label="Permalink to &quot;跨域请求如何传输 cookie&quot;">​</a></h2><ol><li>响应头设置 Access-Control-Allow-Credentials 等于 true</li><li>Access-Control-Allow-Origin 不能设置成 * （Cookie 的 SameSite 属性如果是 Lax 可能也会导致带不上去）</li><li>前端设置 withCredentials: true</li></ol><h2 id="常见的问题" tabindex="-1">常见的问题 <a class="header-anchor" href="#常见的问题" aria-label="Permalink to &quot;常见的问题&quot;">​</a></h2><h3 id="session-和-cookie-有什么区别" tabindex="-1">session 和 cookie 有什么区别？ <a class="header-anchor" href="#session-和-cookie-有什么区别" aria-label="Permalink to &quot;session 和 cookie 有什么区别？&quot;">​</a></h3><p>cookie 一般用于登录验证，存储用户信息，大小为 4KB，会随着网络请求携带给服务端</p><p>session 一般存储在服务端，常用于与 Cookie 配合做登录检验</p><h3 id="token-和-cookie-有什么区别" tabindex="-1">token 和 cookie 有什么区别？ <a class="header-anchor" href="#token-和-cookie-有什么区别" aria-label="Permalink to &quot;token 和 cookie 有什么区别？&quot;">​</a></h3><ul><li>cookie 是 HTTP 的内容，token 是自定义的数据</li><li>cookie 可以默认存储在浏览器中，token 需要自行存储</li><li>token 没有跨域限制，cookie 存在跨域限制</li><li>token 常用于 CSRF 或者 JWT（JSON WEB TOKEN）</li><li>Cookie 常于 Session 配合，做用户登录鉴权</li></ul><h3 id="cookie-的字段有哪些" tabindex="-1">Cookie 的字段有哪些？ <a class="header-anchor" href="#cookie-的字段有哪些" aria-label="Permalink to &quot;Cookie 的字段有哪些？&quot;">​</a></h3><ul><li><p>基本属性:</p><ul><li>name</li><li>value</li></ul></li><li><p>访问性：</p><ul><li>expire</li><li>path</li><li>domain</li></ul></li><li><p>安全性：</p><ul><li>secure</li><li>httpOnly</li><li>sameSite</li></ul></li></ul><h3 id="session-和-jwt-哪个更合适" tabindex="-1">Session 和 JWT 哪个更合适？ <a class="header-anchor" href="#session-和-jwt-哪个更合适" aria-label="Permalink to &quot;Session 和 JWT 哪个更合适？&quot;">​</a></h3><ul><li><p>Session</p><ul><li>优点: <ol><li>易于学习</li><li>用户信息存储在服务器，可以快速封禁某个用户</li></ol></li><li>缺点: <ol><li>占用服务器资源，硬件成本高</li><li>多进程、多服务器时，不好同步 （需要第三方缓存， Redis）</li><li>Session 需要配合 Cookie 使用，cookie 有域名限制</li></ol></li></ul></li><li><p>Json Web Token</p><ul><li>优点: <ol><li>存储在客户端，不占用服务端资源</li><li>易于同步</li><li>没有跨域限制</li></ol></li><li>缺点: <ol><li>无法快速封禁用户</li><li>Token 不安全，一但秘钥被泄漏，容易窃取用户信息</li><li>Token很大，影响请求体积</li></ol></li></ul></li><li><p>使用场景:</p><ul><li>用户信息安全 -&gt; 使用 Session</li><li>没有特殊要求 -&gt; 使用 JWT</li></ul></li></ul><h3 id="如何实现-sso-单点登录" tabindex="-1">如何实现 SSO 单点登录 <a class="header-anchor" href="#如何实现-sso-单点登录" aria-label="Permalink to &quot;如何实现 SSO 单点登录&quot;">​</a></h3><h4 id="如果主域名一致-基于-cookie" tabindex="-1">如果主域名一致 （基于 Cookie） <a class="header-anchor" href="#如果主域名一致-基于-cookie" aria-label="Permalink to &quot;如果主域名一致 （基于 Cookie）&quot;">​</a></h4><p>Cookie 默认跨域不共享</p><p>可以通过设置 Cookie 的 domain 为相同的主域名，即可共享 Cookie</p><p>比如 www.baidu.com、image.baidu.com 主域名是相同的，设置 cookie domain 为主域名，即可共享 cookie</p><p><img src="'+s+'" alt="流程"></p><h4 id="如果主域名不一致" tabindex="-1">如果主域名不一致 <a class="header-anchor" href="#如果主域名不一致" aria-label="Permalink to &quot;如果主域名不一致&quot;">​</a></h4><ol><li>使用 SSO 第三方登录， 获取 ticket 返回给 A、B 系统</li></ol><p><img src="'+r+'" alt="流程"></p><ol start="2"><li>OAuth2.0</li></ol><p>第三方登录（例如微信扫码登录）</p><p><img src="'+n+'" alt="流程"></p>',36),h=[d];function p(u,k,m,b,C,_){return o(),l("div",null,h)}const A=i(c,[["render",p]]);export{q as __pageData,A as default};
