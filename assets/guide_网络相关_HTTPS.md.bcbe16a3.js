import{_ as a,o as t,c as e,Q as i}from"./chunks/framework.b6910bb2.js";const l="/vitePress-blob/assets/8.428d7ec3.jpg",s="/vitePress-blob/assets/9.7081f11f.jpg",o="/vitePress-blob/assets/10.80b27028.jpg",r="/vitePress-blob/assets/11.8b44a308.jpg",h="/vitePress-blob/assets/12.c1a5b37b.jpg",S=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{},"headers":[],"relativePath":"guide/网络相关/HTTPS.md","filePath":"guide/网络相关/HTTPS.md","lastUpdated":1745215725000}'),T={name:"guide/网络相关/HTTPS.md"},n=i('<h1 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h1><h2 id="http-和-https-的区别" tabindex="-1">HTTP 和 HTTPS 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;HTTP 和 HTTPS 的区别&quot;">​</a></h2><ol><li>HTTP 是超文本传输协议，明文传输、简单、无状态，而 HTTPS 是在 HTTP 基础上增加了 SSL 协议，更加安全</li><li>HTTP 协议默认端口是 80，HTTPS 协议默认端口是 443</li><li>HTTPS 需要 CA 证书、相对于 HTTP 费用更高</li></ol><h2 id="https-演进过程" tabindex="-1">HTTPS 演进过程 <a class="header-anchor" href="#https-演进过程" aria-label="Permalink to &quot;HTTPS 演进过程&quot;">​</a></h2><h3 id="第一版对称加密-不安全" tabindex="-1">第一版对称加密 - 不安全 <a class="header-anchor" href="#第一版对称加密-不安全" aria-label="Permalink to &quot;第一版对称加密 - 不安全&quot;">​</a></h3><p><img src="'+l+'" alt="流程"></p><h3 id="非对称加密-传输效率低" tabindex="-1">非对称加密 - 传输效率低 <a class="header-anchor" href="#非对称加密-传输效率低" aria-label="Permalink to &quot;非对称加密 - 传输效率低&quot;">​</a></h3><p><img src="'+s+'" alt="流程"></p><h3 id="对称加密与非对称加密结合-存在中间人攻击" tabindex="-1">对称加密与非对称加密结合 - 存在中间人攻击 <a class="header-anchor" href="#对称加密与非对称加密结合-存在中间人攻击" aria-label="Permalink to &quot;对称加密与非对称加密结合 - 存在中间人攻击&quot;">​</a></h3><p><img src="'+o+'" alt="流程"></p><h3 id="通过数字证书校验网站的真实性和获取网站的公钥" tabindex="-1">通过数字证书校验网站的真实性和获取网站的公钥 <a class="header-anchor" href="#通过数字证书校验网站的真实性和获取网站的公钥" aria-label="Permalink to &quot;通过数字证书校验网站的真实性和获取网站的公钥&quot;">​</a></h3><p>之前传输的是密钥，这种方式传输的是装有密钥的保险箱，就算获取到了保险箱，也没有保险箱的钥匙🔑</p><p><img src="'+r+'" alt="流程"></p><ol><li>浏览器将对称加密方法列表、非对称加密方法列表、随机数 A 传输给服务端</li><li>服务器接受后，将对称加密、非对称加密方法、服务器生成的随机数 B 、数字证书发送给浏览器</li><li>浏览器接受后，验证证书的可靠性，并获取证书内的非对称加密的公钥</li><li>浏览器通过 2 个随机数生成新的随机数 C，并通过非对成加密的公钥对随机数 C 进行加密发送给服务器</li><li>服务器确认后，服务器与浏览器通过 3 个随机数生成对称加密密钥，进行数据传输</li></ol><h2 id="如何验证证书的可靠性" tabindex="-1">如何验证证书的可靠性 <a class="header-anchor" href="#如何验证证书的可靠性" aria-label="Permalink to &quot;如何验证证书的可靠性&quot;">​</a></h2><ol><li>浏览器获取到证书后，通过 CA 相同的 Hash 算法对证书信息进行加密得到摘要 A</li><li>通过 CA 的公钥对证书内的数字签名进行解密，获取到摘要 B</li><li>如果 AB 相同，则证书可靠</li></ol><h2 id="什么是-https-中间人攻击-如何预防" tabindex="-1">什么是 HTTPS 中间人攻击？如何预防？ <a class="header-anchor" href="#什么是-https-中间人攻击-如何预防" aria-label="Permalink to &quot;什么是 HTTPS 中间人攻击？如何预防？&quot;">​</a></h2><ol><li>先说下 HTTPS 传输过程</li><li>客户端和服务端通信之间，新增一个中间人，伪造 CA 证书和加密数据，获取服务器和客户端的通信信息</li></ol><p><img src="'+h+'" alt="流程"></p><p>如何预防？</p><p>使用正规厂商的第三方证书</p>',21),c=[n];function p(d,P,_,b,m,u){return t(),e("div",null,c)}const f=a(T,[["render",p]]);export{S as __pageData,f as default};
