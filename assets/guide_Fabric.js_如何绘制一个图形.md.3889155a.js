import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.b6910bb2.js";const p="/vitePress-blob/assets/7.9514225d.png",o="/vitePress-blob/assets/8.9aa69160.png",e="/vitePress-blob/assets/9.1e766c59.png",t="/vitePress-blob/assets/10.655eecbc.png",c="/vitePress-blob/assets/11.58a7f11b.png",r="/vitePress-blob/assets/16.787d12a1.png",A=JSON.parse('{"title":"如何绘制一个图形","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Fabric.js/如何绘制一个图形.md","filePath":"guide/Fabric.js/如何绘制一个图形.md","lastUpdated":1745215725000}'),E={name:"guide/Fabric.js/如何绘制一个图形.md"},y=l(`<h1 id="如何绘制一个图形" tabindex="-1">如何绘制一个图形 <a class="header-anchor" href="#如何绘制一个图形" aria-label="Permalink to &quot;如何绘制一个图形&quot;">​</a></h1><p>上一节中，大致了解了 Fabric 的内部结构，并且知道 Fabric.js 拥有俩层 Canvas。</p><p>上层 Canvas 称之为动态层，用于处理交互相关以及事件绑定</p><p>下层 Canvas 称之为静态层，用于获取数据，通过数据绘制图形</p><p>之前有编写过 React 的同学应该对父子组件的单向数据流有一定的印象，而 Fabric.js 的分层结构设计就很类似于这种单向数据流思想，</p><p>动态层用于获取数据输出到静态层进行渲染。</p><p>在这一节中，我们将以绘制矩形为例，了解 Fabric.js 是如何实现矩形的绘制的？</p><h2 id="fabric-js-是如何绘制矩形的" tabindex="-1">Fabric.js 是如何绘制矩形的 <a class="header-anchor" href="#fabric-js-是如何绘制矩形的" aria-label="Permalink to &quot;Fabric.js 是如何绘制矩形的&quot;">​</a></h2><p>在 Fabric.js 中绘制矩形也非常简单，只需要初始化画布，添加矩形对象即可，代码如下👇:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- html --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">canvas</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;canvas&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">canvas</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- html --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">canvas</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;canvas&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">canvas</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// js</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">canvas</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> fabric.</span><span style="color:#B392F0;">Canvas</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;canvas&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">canvas.</span><span style="color:#B392F0;">setWidth</span><span style="color:#E1E4E8;">(window.innerWidth);</span></span>
<span class="line"><span style="color:#E1E4E8;">canvas.</span><span style="color:#B392F0;">setHeight</span><span style="color:#E1E4E8;">(window.innerHeight);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rect</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> fabric.</span><span style="color:#B392F0;">Rect</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//距离左边的距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    top: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//距离上边的距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    fill: </span><span style="color:#9ECBFF;">&quot;red&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//填充的颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">    width: </span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//矩形宽度</span></span>
<span class="line"><span style="color:#E1E4E8;">    height: </span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//矩形高度</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">canvas.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(rect);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// js</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">canvas</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> fabric.</span><span style="color:#6F42C1;">Canvas</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;canvas&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">canvas.</span><span style="color:#6F42C1;">setWidth</span><span style="color:#24292E;">(window.innerWidth);</span></span>
<span class="line"><span style="color:#24292E;">canvas.</span><span style="color:#6F42C1;">setHeight</span><span style="color:#24292E;">(window.innerHeight);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rect</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> fabric.</span><span style="color:#6F42C1;">Rect</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">    left: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//距离左边的距离</span></span>
<span class="line"><span style="color:#24292E;">    top: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//距离上边的距离</span></span>
<span class="line"><span style="color:#24292E;">    fill: </span><span style="color:#032F62;">&quot;red&quot;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//填充的颜色</span></span>
<span class="line"><span style="color:#24292E;">    width: </span><span style="color:#005CC5;">200</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//矩形宽度</span></span>
<span class="line"><span style="color:#24292E;">    height: </span><span style="color:#005CC5;">200</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//矩形高度</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">canvas.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(rect);</span></span></code></pre></div><p>通过代码可以看到，Fabric.js 通过实例化对象的方式将 Canvas 的绘制逻辑进行的隐藏，使用者只需要关心传入对应的参数即可在 Canvas 中绘制出相对应的元素。</p><p><img src="`+p+'" alt="初始状态图"></p><h2 id="初始化画布" tabindex="-1">初始化画布 <a class="header-anchor" href="#初始化画布" aria-label="Permalink to &quot;初始化画布&quot;">​</a></h2><p>在源码中， new Fabric.Canvas 会初始化动态层、静态层以及缓冲层 Canvas。</p><p><img src="'+o+'" alt="初始状态图"></p><p>进而对 Canvas 进行分辨率矫正的操作，为何需要做分辨率矫正，可以通过这篇文章 <a href="https://enson0131.github.io/vitePress-blob/guide/canvas/Canvas%E5%B0%BA%E5%AF%B8%E5%8F%8A%E5%88%86%E8%BE%A8%E7%8E%87%E7%9F%AB%E6%AD%A3" target="_blank" rel="noreferrer">Canvas 尺寸与分辨率矫正</a> 查看</p><p><img src="'+e+'" alt="alt text"></p><p>动态层 Canvas 还会做事件绑定的逻辑操作👇</p><p><img src="'+t+`" alt="alt text"></p><p>而静态层 Canvas 将控制渲染 👇</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">fabric.StaticCanvas </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fabric.util.</span><span style="color:#B392F0;">createClass</span><span style="color:#E1E4E8;">(fabric.CommonMethods, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">initialize</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">el</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        options </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (options </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {});</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.renderAndResetBound </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.renderAndReset.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.requestRenderAllBound </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.requestRenderAll.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">_initStatic</span><span style="color:#E1E4E8;">(el, options);</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">fabric.StaticCanvas </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fabric.util.</span><span style="color:#6F42C1;">createClass</span><span style="color:#24292E;">(fabric.CommonMethods, {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">initialize</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">el</span><span style="color:#24292E;">, </span><span style="color:#E36209;">options</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        options </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (options </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {});</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.renderAndResetBound </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.renderAndReset.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.requestRenderAllBound </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.requestRenderAll.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">_initStatic</span><span style="color:#24292E;">(el, options);</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div><p>这里面最主要的逻辑就是 <code>requestRenderAll</code>, 这个方法就会调用 <code>renderCanvas</code> 的方法</p><p><img src="`+c+`" alt="alt text"></p><p>在 _renderObjects 中将遍历所有的元素，进行渲染。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">_renderObjects</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ctx</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">objects</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> i, len;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, len </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> objects.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len; </span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    objects[i] </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> objects[i].</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(ctx);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">_renderObjects</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">ctx</span><span style="color:#24292E;">, </span><span style="color:#E36209;">objects</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> i, len;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> objects.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len; </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">i) {</span></span>
<span class="line"><span style="color:#24292E;">    objects[i] </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> objects[i].</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(ctx);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="实例化对象" tabindex="-1">实例化对象 <a class="header-anchor" href="#实例化对象" aria-label="Permalink to &quot;实例化对象&quot;">​</a></h2><p>虽然我们已经明白了 canvas 的绘制原理，但是一个对象（2d元素）到底是怎么绘制到 canvas 上去的，它们的移动怎么实现的？具体细节我们还不是很清楚。</p><p>fabric.Object 是元素的根类型，因此需要从 fabric.Object 根类型看起了。</p><p>由于 fabric 中的 2d 元素都是以面向对象的形式实现的, 而 Rect （矩形类） 继承 fabric.Object，实现了自己的 render 方法，</p><p>我们将通过一张 UML 类图更直观的方便我们的理解。</p><p><img src="`+r+'" alt="alt text"></p><p>从图中可以看出各个元素类将实现自己的 render 方法，通过调用 render 方法，将各自图形绘制到 Canvas 中。</p><p>而在执行 canvas.add 的时候，会将元素对象 push 到一个数据数组内，进行遍历渲染。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/7103457175413981191" target="_blank" rel="noreferrer">https://juejin.cn/post/7103457175413981191</a></li><li><a href="https://keelii.com/2021/05/09/fabricjs-internals" target="_blank" rel="noreferrer">https://keelii.com/2021/05/09/fabricjs-internals</a></li></ul>',36),i=[y];function d(F,h,b,C,v,u){return a(),n("div",null,i)}const _=s(E,[["render",d]]);export{A as __pageData,_ as default};
