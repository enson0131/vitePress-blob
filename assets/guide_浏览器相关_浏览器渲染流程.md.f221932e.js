import{_ as l,o as i,c as e,Q as a}from"./chunks/framework.b6910bb2.js";const o="/vitePress-blob/assets/3.8bc85ddd.png",t="/vitePress-blob/assets/4.9caf6b36.png",s="/vitePress-blob/assets/5.bbea4579.jpg",m=JSON.parse('{"title":"浏览器渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"guide/浏览器相关/浏览器渲染流程.md","filePath":"guide/浏览器相关/浏览器渲染流程.md","lastUpdated":1709084980000}'),r={name:"guide/浏览器相关/浏览器渲染流程.md"},p=a('<h1 id="浏览器渲染流程" tabindex="-1">浏览器渲染流程 <a class="header-anchor" href="#浏览器渲染流程" aria-label="Permalink to &quot;浏览器渲染流程&quot;">​</a></h1><h2 id="浏览器渲染流程-1" tabindex="-1">浏览器渲染流程 <a class="header-anchor" href="#浏览器渲染流程-1" aria-label="Permalink to &quot;浏览器渲染流程&quot;">​</a></h2><ol><li><p>发出请求到页面首次绘制</p><ul><li>第一阶段: 页面提交请求到服务器响应，这时候页面还是之前的页面</li><li>第二阶段: 获取到响应数据提交到渲染进程，进行 HTML 解析、CSS 加载、JS 加载、JS 执行、CSSOM 解析、布局树生成、页面绘制</li><li>第三阶段: 等首次加载完成后，页面一点点被渲染</li></ul></li><li><p>HTML 解析</p></li><li><p>生成 CSSOM 树</p><p>CSS 不会阻塞 HTML 解析，但是会阻塞页面渲染，因为要生成渲染树</p></li><li><p>生成布局树</p><p>去除不显示的节点，计算样式</p></li><li><p>分层和合成机制</p><ul><li><p>分层: 分层树在布局树之后，分层树的每一个节点都是图层，如没有，则和父节点同一个图层</p></li><li><p>绘制阶段: 根据图层在绘制阶段生成绘制指令</p></li><li><p>光栅化: 根据绘制指令，将每个图层都绘制成一张图片</p></li><li><p>合成: 合成线程将多张图片合成一张图片，然后显示在屏幕上 (由合成线程完成，不影响主线程)</p><ul><li>优化操作1: 合成线程内会维护一个光栅化线程池，将绘制指令列表提交到 GPU 进行光栅化，生成位图，放在内存中</li><li>优化操作2: 分块，合成线程将图层分块，优先渲染离屏幕最近的图块</li><li><img src="'+o+'" alt="合成线程"></li></ul></li></ul></li><li><p>页面显示</p></li></ol><h2 id="常见的问题" tabindex="-1">常见的问题 <a class="header-anchor" href="#常见的问题" aria-label="Permalink to &quot;常见的问题&quot;">​</a></h2><h3 id="_1-从输入-url-到页面渲染完成-发生了什么" tabindex="-1">1 从输入 URL 到页面渲染完成，发生了什么？ <a class="header-anchor" href="#_1-从输入-url-到页面渲染完成-发生了什么" aria-label="Permalink to &quot;1 从输入 URL 到页面渲染完成，发生了什么？&quot;">​</a></h3><ol><li>浏览器会根据用户输入的内容判断是关键字还是URL</li><li>如果是关键字，会将其组成成带有搜索关键字的URL，通过IPC进程通信发送给网络进程</li><li>网络进程发起请求前，会判断是否命中强缓存，如命中直接返回存储资源</li><li>否则发起请求，根据 DNS 解析获取域名对应的 IP 地址，进行 TCP、HTTP 连接</li><li>服务端收到请求后，会判断是否命中协商缓存，如命中则返回304状态码</li><li>如返回的是301、302状态码，浏览器会根据响应头返回的location字段，进行重定向</li><li>如是正常返回资源类型，浏览器会根据 content-type 对资源做相对应的操作，如果是下载类型则进行下载，如果是html类型则会提交到渲染进程进行解析</li><li>解析 HTML，转换成浏览器能识别的 <code>DOM 树</code></li><li>解析 CSS，转化成浏览器能识别的 <code>CSS 样式树</code></li><li>根据 DOM 和 CSS 样式树，通过 布局计算生成 <code>布局树</code></li><li>根据布局树上的<code>分层属性（z-index）</code>，生成<code>分层树</code></li><li>根据分层树，生成绘制指令列表</li><li>渲染主线程会将绘制指令列表提交给合成线程</li><li>合成线程会维护一个<code>光栅化线程池</code>，将绘制指令列表提交到 <code>GPU</code> 进行<code>光栅化</code>，生成位图，放在内存中</li><li>合成线程通信浏览器进程，浏览器进程将内存中的数据输出到显卡的后缓存区，在下一帧绘制之前，显卡的后缓冲区与前缓冲区对换，显示屏读取前缓冲区数据，显示到屏幕上</li></ol><p><img src="'+t+'" alt="整体流程"></p><h3 id="_2-回流和重绘有什么区别" tabindex="-1">2 回流和重绘有什么区别 <a class="header-anchor" href="#_2-回流和重绘有什么区别" aria-label="Permalink to &quot;2 回流和重绘有什么区别&quot;">​</a></h3><p>回流：元素尺寸、定位改变，可能会影响到其他元素的位置</p><p>重绘：元素外观改变，如背景色、颜色，元素尺寸位置不改变且不影响其他元素</p><p>减少回流的方法：</p><ol><li>集中修改 <ul><li>修改样式，使用 class</li><li>修改前将 DOM 改成 display: none，修改后再显示</li><li>使用 DocumentFragment</li><li>resize、scroll 事件，使用防抖</li></ul></li><li>使用 BFC <ul><li>隔离内部元素对外部元素的影响</li></ul></li><li>脱离文档流 <ul><li>position: absolute、fixed</li><li>float</li></ul></li><li>提升合成图层 <ul><li>CSS3 属性: will-change、transform: translate3d(0);</li></ul></li><li>不是用 offsetHeight、getBoundingClientRect <ul><li>使用 intersectionObserver API - 判断元素是否在可视区域内</li></ul></li></ol><p>BFC: 块级格式化上下文 特点: BFC 内部元素不会影响到外部元素 形成条件:</p><ol><li>HTML 元素</li><li>overflow: hidden、auto、scroll</li><li>position: absolute、fixed</li><li>float 元素</li><li>display: inline-block、flex、inline-flex等</li></ol><h3 id="_3-渲染流程图" tabindex="-1">3 渲染流程图 <a class="header-anchor" href="#_3-渲染流程图" aria-label="Permalink to &quot;3 渲染流程图&quot;">​</a></h3><p><img src="'+s+'" alt="渲染流程图"></p><p>JS 会阻塞 HTML 的解析和渲染</p><p>CSS 不会阻塞 HTML 解析，但会阻塞 DOM 渲染，还会阻塞 JS 的执行</p><p>为什么 CSS 会阻塞 JS 的执行？</p><p>因为 JS 可能会操作 DOM 节点和 CSS 样式，因此浏览器为了获取到最新的 CSS 样式，样式表会在后面的 JS 执行前先加载执行完毕，所以 CSS 会阻塞 JS 的执行</p>',20),c=[p];function d(n,_,u,h,S,b){return i(),e("div",null,c)}const C=l(r,[["render",d]]);export{m as __pageData,C as default};
