import{_ as t,o as c,c as s,k as e,a}from"./chunks/framework.b6910bb2.js";const b=JSON.parse('{"title":"React 是如何渲染的","description":"","frontmatter":{},"headers":[],"relativePath":"guide/React/React是如何渲染的.md","filePath":"guide/React/React是如何渲染的.md","lastUpdated":1697879070000}'),o={name:"guide/React/React是如何渲染的.md"},r=e("h1",{id:"react-是如何渲染的",tabindex:"-1"},[a("React 是如何渲染的 "),e("a",{class:"header-anchor",href:"#react-是如何渲染的","aria-label":'Permalink to "React 是如何渲染的"'},"​")],-1),n=e("h2",{id:"react-16-以前",tabindex:"-1"},[a("React 16 以前 "),e("a",{class:"header-anchor",href:"#react-16-以前","aria-label":'Permalink to "React 16 以前"'},"​")],-1),d=e("p",null,"在浏览器中 js 线程与渲染线程是互斥的，如果 js 线程长期占用着浏览器的主线程，那么界面将长时间不更新，在动画等一些场景下会造成卡顿效果。",-1),i=e("p",null,"因为 Stack Reconciler 是一个同步的递归过程，随着业务复杂度增加，Stack Reconciler 需要的调和时间会变长，",-1),_=e("p",null,"这意味着 js 将长时间占用浏览器，进而导致页面卡顿",-1),l=[r,n,d,i,_];function h(p,R,m,u,f,k){return c(),s("div",null,l)}const g=t(o,[["render",h]]);export{b as __pageData,g as default};
