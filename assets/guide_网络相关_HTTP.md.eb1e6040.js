import{_ as a,o as t,c as e,Q as l}from"./chunks/framework.b6910bb2.js";const i="/vitePress-blob/assets/5.c8205ece.jpg",o="/vitePress-blob/assets/6.76a1cb50.jpg",r="/vitePress-blob/assets/7.ee9188c9.jpg",H=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"guide/网络相关/HTTP.md","filePath":"guide/网络相关/HTTP.md","lastUpdated":1732247816000}'),h={name:"guide/网络相关/HTTP.md"},T=l('<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><h2 id="http-0-9" tabindex="-1">HTTP 0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP 0.9&quot;">​</a></h2><p>早期做学术研究使用，只是单纯的文本传输（只有请求行、没有请求头和请求体）</p><h2 id="http1-0" tabindex="-1">HTTP1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;HTTP1.0&quot;">​</a></h2><p>支持图片、视频传输，但传输效率太低</p><p>核心需求：支持多种类型的文件下载（引入了请求头和响应头）</p><h2 id="http1-1" tabindex="-1">HTTP1.1 <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;HTTP1.1&quot;">​</a></h2><h3 id="持久连接-keep-alive" tabindex="-1">持久连接 keep-alive <a class="header-anchor" href="#持久连接-keep-alive" aria-label="Permalink to &quot;持久连接 keep-alive&quot;">​</a></h3><p>在此之前一个 HTTP 请求需要建立一个 TCP 连接</p><p>目前浏览器中对于 <strong>同一个域名</strong>，默认允许同时建立 6 个 TCP 连接</p><h3 id="管道化连接" tabindex="-1">管道化连接 <a class="header-anchor" href="#管道化连接" aria-label="Permalink to &quot;管道化连接&quot;">​</a></h3><p>将串行请求改成并行请求</p><h3 id="支持虚拟主机" tabindex="-1">支持虚拟主机 <a class="header-anchor" href="#支持虚拟主机" aria-label="Permalink to &quot;支持虚拟主机&quot;">​</a></h3><p>HTTP 根据 Host 去区分同一 IP 物理机子上的不同虚拟主机</p><h3 id="对动态生成的内容提供完美支持" tabindex="-1">对动态生成的内容提供完美支持 <a class="header-anchor" href="#对动态生成的内容提供完美支持" aria-label="Permalink to &quot;对动态生成的内容提供完美支持&quot;">​</a></h3><p>Chunk transfer 机制</p><h3 id="cookie、完全机制" tabindex="-1">Cookie、完全机制 <a class="header-anchor" href="#cookie、完全机制" aria-label="Permalink to &quot;Cookie、完全机制&quot;">​</a></h3><h3 id="主要问题" tabindex="-1">主要问题 <a class="header-anchor" href="#主要问题" aria-label="Permalink to &quot;主要问题&quot;">​</a></h3><ul><li><ol><li>HTTP/1.1 对头阻塞问题 在 HTTP 中，因为前一条请求因某些原因没有及时返回，会导致后面的请求无法发起，容易导致对头阻塞（串行）。虽然 HTTP1.1 引入了管道化技术尝试解决队头阻塞问题，但服务端还是需要按顺序处理请求并返回，因此阻塞问题依然存在</li></ol></li><li><ol start="2"><li>带宽利用率不理想</li></ol><ul><li>原因: <ul><li>TCP 的慢启动: 传输数据的速度从慢到快</li><li>同时开启多个 TCP 连接，那么这些连接会竞争固定的带宽（带宽不足时，TCP 传输速度会变慢）</li></ul></li></ul></li></ul><h2 id="http-1-0-与-http-1-1-的-区别" tabindex="-1">HTTP/1.0 与 HTTP/1.1 的 区别？ <a class="header-anchor" href="#http-1-0-与-http-1-1-的-区别" aria-label="Permalink to &quot;HTTP/1.0 与 HTTP/1.1 的 区别？&quot;">​</a></h2><h3 id="_1-连接方面" tabindex="-1">1 连接方面 <a class="header-anchor" href="#_1-连接方面" aria-label="Permalink to &quot;1 连接方面&quot;">​</a></h3><p>持久化连接: HTTP1.1 支持持久化连接，减少每次 HTTP 请求都需要建立 TCP 连接的耗时</p><p>管道化连接：提高请求效率</p><h3 id="_2-缓存方面" tabindex="-1">2 缓存方面 <a class="header-anchor" href="#_2-缓存方面" aria-label="Permalink to &quot;2 缓存方面&quot;">​</a></h3><p>HTTP1.1 新增了协商缓存的字段 ETag 比 if-None-Match 更加紧准</p><h3 id="_3-新增-host-字段" tabindex="-1">3 新增 Host 字段 <a class="header-anchor" href="#_3-新增-host-字段" aria-label="Permalink to &quot;3 新增 Host 字段&quot;">​</a></h3><p>根据 Host 区分同一 IP 服务器上的不同网站</p><p>之前只能通过 IP 区分网站</p><h3 id="_4-请求资源方面" tabindex="-1">4 请求资源方面 <a class="header-anchor" href="#_4-请求资源方面" aria-label="Permalink to &quot;4 请求资源方面&quot;">​</a></h3><p>添加范围请求 （206 状态码）</p><h3 id="_5-新增了请求方法" tabindex="-1">5 新增了请求方法 <a class="header-anchor" href="#_5-新增了请求方法" aria-label="Permalink to &quot;5 新增了请求方法&quot;">​</a></h3><p>PUT、HEAD、OPTIONS 等</p><h2 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h2><p>一个域名只有一个 TCP 长连接传输数据 （避规 HTTP 1.1 的 TCP 慢启动和多个 TCP 连接时竞争带宽资源）</p><h3 id="多路复用机制" tabindex="-1">多路复用机制 <a class="header-anchor" href="#多路复用机制" aria-label="Permalink to &quot;多路复用机制&quot;">​</a></h3><p>通过引入二进制分帧层，实现多路复用机制</p><p><img src="'+i+'" alt="整体流程"><img src="'+o+'" alt="整体流程"></p><ol><li>浏览器发起请求，经过二进制分帧层将请求拆分成一个个带请求id的帧，发送给服务端</li><li>服务端收到这些帧后，根据请求id组装成完整请求信息，服务端处理完请求后，将响应请求发送到二进制分帧层，经过二进制分帧层转化为一个个带有响应id的帧发送给浏览器</li><li>浏览器收到这些帧后，会组合成一个完整的响应请求</li></ol><p>实现基础： <em><strong>HTTP2 是一个二进制协议</strong></em>，在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础</p><h3 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h3><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p><h3 id="设置请求优先级" tabindex="-1">设置请求优先级 <a class="header-anchor" href="#设置请求优先级" aria-label="Permalink to &quot;设置请求优先级&quot;">​</a></h3><h3 id="服务器推送" tabindex="-1">服务器推送 <a class="header-anchor" href="#服务器推送" aria-label="Permalink to &quot;服务器推送&quot;">​</a></h3><h3 id="存在的问题" tabindex="-1">存在的问题 <a class="header-anchor" href="#存在的问题" aria-label="Permalink to &quot;存在的问题&quot;">​</a></h3><p>TCP 协议本身存在的问题：</p><ul><li><ol><li>TCP 的队头阻塞 TCP 传输过程中把一份数据分成多个数据包进行传输，当某个数据包没有按顺序返回，接收端会一直保持连接等待数据包返回，这就阻塞了后续数据包的传输 <img src="'+r+'" alt="整体流程"></li></ol></li><li><ol start="2"><li>TCP 建立连接需要耗时</li></ol></li></ul><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>多路复用技术能有效利用带宽（只有一个TCP连接），缓解 TCP 慢启动带来的问题，解决了 HTTP 队头阻塞问题，同时还支持设置优先级、服务器推送、头部压缩极大的提高了 HTTP 的传输效率</p><h2 id="http2-与-http1-的区别" tabindex="-1">http2 与 http1 的区别？ <a class="header-anchor" href="#http2-与-http1-的区别" aria-label="Permalink to &quot;http2 与 http1 的区别？&quot;">​</a></h2><ol><li>为了解决 HTTP1.1 的队头阻塞问题引入了二进制分帧层</li><li>只建立一个 TCP 连接，解决 HTTP1.1中 TCP 慢启动以及多个 TCP 之间相互竞争带宽问题</li><li>头部压缩，HTTP2 请求头部采用头部压缩，减少数据内容的大小，提高效率</li><li>服务端推送: 服务端可以向客户端推送资源</li></ol><h2 id="http3-0" tabindex="-1">HTTP3.0 <a class="header-anchor" href="#http3-0" aria-label="Permalink to &quot;HTTP3.0&quot;">​</a></h2><p>采用UDP + QUIC协议</p><ol><li>UDP 可以减少连接耗费的 RTT，加快数据传输</li><li>使用 QUIC 协议，可以使用多路复用、TLS、可靠性传输等 TCP 协议的特点</li></ol><p>存在的问题:</p><ol><li>规范的制定和落地有着较大的差异（比如官方的QUIC和谷歌的QUIC协议有较大差异）</li><li>是对底层协议的改造，落地成本高。</li></ol><h2 id="http1-0-1-1-2-0有什么区别" tabindex="-1">HTTP1.0/1.1/2.0有什么区别？ <a class="header-anchor" href="#http1-0-1-1-2-0有什么区别" aria-label="Permalink to &quot;HTTP1.0/1.1/2.0有什么区别？&quot;">​</a></h2><p>这道题应该从HTTP的发展历史的角度出发</p><ol><li>http1.0 在 http0.9 时代新增了图片、视频的传输，同时新增了请求、响应头，支持文件下载，但请求的效率低，因为每个http请求需要一次TCP连接</li><li>HTTP1.1 引入了缓存策略、支持长连接keep-alive等，支持PUT/DELETE/OPTION方法，提高了HTTP的传输效率，但并发请求时会有一个HTTP的头部阻塞问题</li><li>HTTP2 通过引入二进制分帧层、采用多路复用避规了HTTP的头部阻塞问题，还支持头部压缩，提高HTTP的传输效率，服务端推送</li></ol><h2 id="rtt" tabindex="-1">RTT <a class="header-anchor" href="#rtt" aria-label="Permalink to &quot;RTT&quot;">​</a></h2><p>浏览器发送数据包到服务器 + 浏览器接收到服务器确认接收的数据包的往返时间，成为RTT</p>',60),s=[T];function P(n,p,d,c,u,b){return t(),e("div",null,s)}const m=a(h,[["render",P]]);export{H as __pageData,m as default};
