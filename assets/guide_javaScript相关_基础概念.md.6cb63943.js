import{_ as a,o as s,c as l,Q as n}from"./chunks/framework.b6910bb2.js";const p="/vitePress-blob/assets/4.8663f597.png",o="/vitePress-blob/assets/5.83f69d4f.png",_=JSON.parse('{"title":"3 基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"guide/javaScript相关/基础概念.md","filePath":"guide/javaScript相关/基础概念.md","lastUpdated":1707358495000}'),e={name:"guide/javaScript相关/基础概念.md"},t=n('<h1 id="_3-基础概念" tabindex="-1">3 基础概念 <a class="header-anchor" href="#_3-基础概念" aria-label="Permalink to &quot;3 基础概念&quot;">​</a></h1><h2 id="_3-1-闭包" tabindex="-1">3.1 闭包 <a class="header-anchor" href="#_3-1-闭包" aria-label="Permalink to &quot;3.1 闭包&quot;">​</a></h2><p>执行外部函数返回内部函数后，虽然外部函数已经弹出调用栈了，但是内部函数对外部函数变量的引用依然保存在内存中，那么内部函数和这些变量的集合就叫做闭包。</p><p>闭包的好处: 1. 私有变量在内存中持久化</p><p>闭包的坏处: 1. 使用不当会造成内存泄漏</p><h2 id="_3-2-原型" tabindex="-1">3.2 原型 <a class="header-anchor" href="#_3-2-原型" aria-label="Permalink to &quot;3.2 原型&quot;">​</a></h2><p>在 js 中对象是由构造函数创建的，构造函数中会有一个 prototype 属性，指向一个对象，这个对象包含了由该构造函数创建的实例所共享的属性和方法， 由该构造函数创建的实例可以通过 <strong>proto</strong> 属性指向这个对象，这个对象就是我们所说的原型。</p><p>当想要访问对象的某个属性时，如果在当前对象查找不到，就会往该对象的原型查找，对象的原型也会有属于他的原型对象，如此循环，直到 null 停止，这就是我们所说的原型链</p><p>隐式原型: <strong>proto</strong> 显示原型: prototype</p><p>相关方法: 1. hasOwnProperty() 判断属性是否是实例自身的属性 2. Object.getPrototypeOf() 获取实例的原型</p><h2 id="_3-3-作用域" tabindex="-1">3.3 作用域 <a class="header-anchor" href="#_3-3-作用域" aria-label="Permalink to &quot;3.3 作用域&quot;">​</a></h2><p>作用域分成<code>全局作用域</code>、<code>函数作用域</code>、<code>块级作用域</code>，它标识着一个变量是否合法 （编译过程中就已经确认了）</p><p>当查询一个变量时，如果当前作用域查询不到，会往上一级作用域查找，如此循环，直到全局作用域，这就是我们所说的作用域链</p><h2 id="_3-4-执行上下文" tabindex="-1">3.4 执行上下文 <a class="header-anchor" href="#_3-4-执行上下文" aria-label="Permalink to &quot;3.4 执行上下文&quot;">​</a></h2><p>从类型上看</p><ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol><p>从生命周期上看</p><ol><li>创建阶段 <ul><li>this 绑定</li><li>创建词法环境 （let、const会被提升到词法环境）</li><li>创建变量环境 （var 声明的变量会被提升到变量环境）</li></ul></li><li>执行阶段 <ul><li>对变量进行赋值，执行代码</li></ul></li><li>回收阶段 <ul><li>当执行上下文弹出调用站后，会对上下文进行回收</li></ul></li></ol><p>执行上下文栈: 当 JS 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并压入执行栈中，当遇到函数调用时，就会为该函数创建一个新的函数执行上下文压入栈中， 引擎会执行位于执行上下文栈顶的函数，当函数执行完后，执行上下文会从栈中弹出，继续执行下一个上下文，当所有代码都执行完毕后，从栈中弹出全局执行上下文</p><p><img src="'+p+`" alt="执行上下文"></p><h2 id="_3-5-类数组对象" tabindex="-1">3.5 类数组对象 <a class="header-anchor" href="#_3-5-类数组对象" aria-label="Permalink to &quot;3.5 类数组对象&quot;">​</a></h2><p>一个拥有 length 属性和若干索引属性的对象就是类数组对象。</p><p>将类数组对象转化成数组的方法：</p><pre><code>1 Array.from(arrayLike)

2 Array.prototype.slice.call(arrayLike)

3 Array.prototype.concat.apply([], arrayLike)

4 Array.prototype.splice.call(arrayLike, 0)
</code></pre><p>注意： <strong>类数组对象不一定有 iterator 接口，所以不能用拓展运算符</strong></p><p><img src="`+o+`" alt="类数组对象"></p><p>1 arguments 可以使用拓展运算符</p><p>2 可迭代对象（Iteratable Object，例如 [] ）与可枚举对象 (可以通过 for..in 遍历，例如 {} ) 不可用拓展运算符转化</p><h2 id="_3-6-严格模式" tabindex="-1">3.6 严格模式 <a class="header-anchor" href="#_3-6-严格模式" aria-label="Permalink to &quot;3.6 严格模式&quot;">​</a></h2><p>使用 use strict 即可声明严格模式</p><p>目的：</p><ul><li>消除 JavaScript 一些语法不合理、不严谨之处，减少怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li></ul><p>区别：</p><ul><li>禁止使用 with 语句</li><li>禁止 this 关键字指向全局对象</li><li>对象的属性名不能重复</li><li>arguments.callee 被禁止</li></ul><h2 id="_3-7-尾调用" tabindex="-1">3.7 尾调用 <a class="header-anchor" href="#_3-7-尾调用" aria-label="Permalink to &quot;3.7 尾调用&quot;">​</a></h2><p>在函数的最后一步调用另一个函数，称为尾调用（父函数执行上下文弹出调用栈）</p><p>只在严格模式开启</p><h2 id="_3-8-常见的问题" tabindex="-1">3.8 常见的问题 <a class="header-anchor" href="#_3-8-常见的问题" aria-label="Permalink to &quot;3.8 常见的问题&quot;">​</a></h2><h3 id="_3-8-1-map、object、weakmap-的区别" tabindex="-1">3.8.1 Map、Object、WeakMap 的区别 <a class="header-anchor" href="#_3-8-1-map、object、weakmap-的区别" aria-label="Permalink to &quot;3.8.1 Map、Object、WeakMap 的区别&quot;">​</a></h3><ul><li><p>从 key 的角度上看</p><ul><li>Map 的 key 是可以任意的</li><li>Object 的 key 只能是字符串</li><li>WeakMap 的 key 只能是对象</li></ul></li><li><p>从获取长度的角度上看</p><ul><li>Map 通过 size 属性获取键值对的个数</li><li>Object 需要通过 Object.keys() 获取键值对的个数</li><li>WeakMap 没有 size 属性，也没有办法获取键值对的个数</li></ul></li><li><p>从迭代的角度上看</p><ul><li>Map 具有 iterator 属性，可迭代</li><li>Object 可枚举</li><li>WeakMap 不可迭代</li></ul></li><li><p>从存储的性能角度上看</p><ul><li>WeakMap 是一个弱引用关系，不影响引用对象的垃圾回收</li><li>在频繁的增删键值对时，Map 的性能表现更好</li></ul></li></ul><h3 id="_3-8-2-object-is-和-、-的区别" tabindex="-1">3.8.2 Object.is 和 === 、 == 的区别 <a class="header-anchor" href="#_3-8-2-object-is-和-、-的区别" aria-label="Permalink to &quot;3.8.2 Object.is 和 === 、 == 的区别&quot;">​</a></h3><p>1 == 会进行隐式转化</p><p>2 === 不会进行隐私转化</p><p>3 Object.js 和 === 类似，但 NaN 和 NaN 判断相等，+0 和 -0 判断不等</p><h3 id="_3-8-3-什么是-dom-和-bom" tabindex="-1">3.8.3 什么是 DOM 和 BOM <a class="header-anchor" href="#_3-8-3-什么是-dom-和-bom" aria-label="Permalink to &quot;3.8.3 什么是 DOM 和 BOM&quot;">​</a></h3><p>DOM: 文档对象模型，提供了访问和操作网页内容的方法和接口</p><p>BOM: 浏览器对象模型，提供了与浏览器窗口进行交互的方法和接口</p><h3 id="_3-8-4-for-in-和-for-of-的区别" tabindex="-1">3.8.4 for...in 和 for...of 的区别 <a class="header-anchor" href="#_3-8-4-for-in-和-for-of-的区别" aria-label="Permalink to &quot;3.8.4 for...in 和 for...of 的区别&quot;">​</a></h3><p>for...in 是对属性的遍历，常用于遍历可枚举的对象，例如对象，但它会遍历原型上的属性，所以一般我们会和 Object.hasOwnProperty() 一起使用</p><p>for...of 是对值的遍历，常用于遍历可迭代的对象，例如数组。</p><h3 id="_3-8-5-ajax、axios、fetch-的区别" tabindex="-1">3.8.5 ajax、axios、fetch 的区别 <a class="header-anchor" href="#_3-8-5-ajax、axios、fetch-的区别" aria-label="Permalink to &quot;3.8.5 ajax、axios、fetch 的区别&quot;">​</a></h3><ul><li>Ajax 是一个创建交互式网页应用开发技术，一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</li><li>Axios 是一个基于 promise 封装的 HTTP 请求库，可以用在浏览器和 node.js 中</li><li>Fetch 基于 Promise 设计，是一个可以发送网络请求的 API 他的缺点 <ul><li>1 fetch 只对网络请求报错，对 400、500 都当做成功的请求，需要封装去处理</li><li>2 fetch 默认不会带 cookie，需要添加配置项: <code>fetch(url, { credentials: &#39;include&#39; })</code></li><li>3 fetch 不支持 abort，不支持超时控制，使用 setTimeout/Promise.reject 实现，但无法阻止网络请求过程，造成了流量的浪费</li><li>4 fetch 没有办法原生监测请求的进度，而 XHR 可以</li></ul></li></ul><h3 id="_3-8-6-javascript-为什么要进行变量提升-它导致什么问题" tabindex="-1">3.8.6 JavaScript 为什么要进行变量提升，它导致什么问题？ <a class="header-anchor" href="#_3-8-6-javascript-为什么要进行变量提升-它导致什么问题" aria-label="Permalink to &quot;3.8.6 JavaScript 为什么要进行变量提升，它导致什么问题？&quot;">​</a></h3><p>1 变量提升的表现</p><p>在函数某些地方声明了变量，都会被提升到函数的头部，使得我们在声明前访问变量都不会报错</p><p>2 变量提升的原因</p><p>JavaScript 是一个解释型语言，他会执行 js 代码前会有一个编译过程，创建执行上下文，创建变量环境，例如 var 声明的变量会被提升到变量环境中</p><p>当访问一个变量的时候，会在当前上下文的变量环境查询</p><p>3 导致的问题</p><p>1 for 循环的变量不会被清除</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello world&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> temp.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(temp[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(i); </span><span style="color:#6A737D;">// 11</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;hello world&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> temp.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(temp[i]);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(i); </span><span style="color:#6A737D;">// 11</span></span></code></pre></div><p>2 一些条件语句为false中的变量会被提升，导致变量覆盖</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Date</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(temp);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> temp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello world&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// undefined</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Date</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(temp);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> temp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;hello world&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// undefined</span></span></code></pre></div>`,63),r=[t];function c(i,y,E,h,d,u){return s(),l("div",null,r)}const b=a(e,[["render",c]]);export{_ as __pageData,b as default};
