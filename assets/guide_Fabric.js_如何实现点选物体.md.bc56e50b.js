import{_ as s,o as a,c as o,Q as n}from"./chunks/framework.b6910bb2.js";const t="/vitePress-blob/assets/1.4d5a2b6a.gif",p="/vitePress-blob/assets/image-3.bc73d938.png",l="/vitePress-blob/assets/2.05638152.gif",e="/vitePress-blob/assets/image-4.7e66fc23.png",r="/vitePress-blob/assets/image-5.c2db871f.png",u=JSON.parse('{"title":"如何实现点选物体","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Fabric.js/如何实现点选物体.md","filePath":"guide/Fabric.js/如何实现点选物体.md","lastUpdated":1736921952000}'),c={name:"guide/Fabric.js/如何实现点选物体.md"},i=n('<h1 id="如何实现点选物体" tabindex="-1">如何实现点选物体 <a class="header-anchor" href="#如何实现点选物体" aria-label="Permalink to &quot;如何实现点选物体&quot;">​</a></h1><p>上一节，我们了解了在 Fabric.js 中，可以通过 <code>transform</code> 进行矩阵运算，从而达到平移、旋转、缩放的目的。</p><p>接下来我们将了解如何对一个物体进行点选，在 Fabric.js 的表现即鼠标移动到元素上，呈现hover状态，移出则显示默认状态。</p><p><img src="'+t+'" alt="点选效果"></p><h2 id="判断是否在矩形内部" tabindex="-1">判断是否在矩形内部 <a class="header-anchor" href="#判断是否在矩形内部" aria-label="Permalink to &quot;判断是否在矩形内部&quot;">​</a></h2><p>如果对于矩形元素来说, 我们可以获取到四个顶点的坐标，进而判断当前的鼠标坐标是否在顶点坐标之内即可。</p><p>例如矩形的左上角顶点坐标是 left、top</p><p>那么我们只需要判断 <code>left &lt;= x &lt;= left + width &amp;&amp; top &lt;= y &lt;= top + height</code> 即可。</p><p>基于此，在 Fabric.js 静态层 Canvas 会有一个 <code>_objects</code> 数组，存储了所有图形的数据，</p><p>此时可以通过从后往前遍历（因为最后添加元素位于数组最后）判断鼠标点是否在元素上。</p><h2 id="包围盒" tabindex="-1">包围盒 <a class="header-anchor" href="#包围盒" aria-label="Permalink to &quot;包围盒&quot;">​</a></h2><p>对于其他图形，例如三角形等，可以引入包围盒的概念，将其他图形转化为矩形进行判断。</p><p>常见的有 OBB、AABB、球模型包围盒</p><p><img src="'+p+'" alt="alt text"></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>AABB（轴对齐包围盒）</strong></td><td>边与坐标轴对齐，由最小点和最大点定义</td><td>计算简单，存储效率高</td><td>对旋转物体可能不紧凑，浪费空间</td><td>静态场景筛选，粗略碰撞检测</td></tr><tr><td><strong>OBB（方向包围盒）</strong></td><td>可任意旋转，由中心点、尺寸向量和旋转矩阵描述</td><td>更紧凑地包围旋转物体</td><td>计算复杂度高</td><td>精确碰撞检测，动态物体包围</td></tr><tr><td><strong>球模型包围盒</strong></td><td>以中心点和半径定义</td><td>旋转无影响，检测简单</td><td>对非球状物体浪费较多空间</td><td>初步碰撞检测，三维场景快速筛选</td></tr></tbody></table><p><img src="'+l+'" alt="alt text"></p><p>我们不难发现，在 Fabric.js 中也是通过 AABB 包围盒进行点选物体的。</p><p>演示地址: <a href="https://enson0131.github.io/mini-fabric-whiteboard/" target="_blank" rel="noreferrer">https://enson0131.github.io/mini-fabric-whiteboard/</a></p><h2 id="点射法" tabindex="-1">点射法 <a class="header-anchor" href="#点射法" aria-label="Permalink to &quot;点射法&quot;">​</a></h2><p>对于矩形，我们可以很方便地计算出点是否在矩形内，在不借助包围盒的情况下，是否可以判断点在多边形内呢？</p><p>显然是可以的，常见的算法是 <code>点射法</code>，这种方法的核心思想是通过从目标点 P(x,y) 向任意方向发射一条射线，通常选择水平或垂直方向以简化计算，然后统计射线与几何区域的边或面相交的次数。</p><ol><li><p>如果射线与边/面的交点数是奇数，点在多边形内部。</p></li><li><p>如果交点数是偶数，点在多边形外部。</p></li></ol><p>大致可以在脑海里想象下👇</p><p><img src="'+e+'" alt="alt text"></p><p>应该有不少同学已经想象到一些边界场景：</p><ol><li><p>点在多边形的顶点上</p></li><li><p>点所在的射线穿过图形的顶点上</p></li><li><p>点的射线穿过图形的一条边</p></li></ol><p><img src="'+r+`" alt="alt text"></p><p>基于第一种场景，可以通过业务场景决定是否在多边形内/外。</p><p>基于第二种场景，常见的会将其判断为一个交点，而第三种场景则可以简单判断为无交点。</p><p>通过 <code>点射法</code>，我们可以将问题转化为射线与多边形各个边的交点，也就是简化成了求解一元线性方程组。</p><p>数学原理: 射线方程：<code>y = b1x + a1</code> 边界线段方程：<code>y = b2x + a2</code> 交点处：<code>b1x + a1 = b2x + a2</code> 求解x坐标：x = <code>-(a1 - a2)/(b1 - b2)</code>。</p><p>下面是一些伪代码:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">b1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// b1 / b2 是斜率</span></span>
<span class="line"><span style="color:#E1E4E8;">  b2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (iLine.d.y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> iLine.o.y) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (iLine.d.x </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> iLine.o.x); </span><span style="color:#6A737D;">// iLine.d 多边形线段的终点、iLine.o 是多边形线段的起点</span></span>
<span class="line"><span style="color:#E1E4E8;">  a1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ey </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b1 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> ex;</span></span>
<span class="line"><span style="color:#E1E4E8;">  a2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> iLine.o.y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b2 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> iLine.o.x;</span></span>
<span class="line"><span style="color:#E1E4E8;">  xi </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">(a1 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> a2) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> (b1 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b2); </span><span style="color:#6A737D;">// 求俩个直接的交点，即求出交点的 x 坐标 即 xi = a1 - a2 / b2;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">b1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// b1 / b2 是斜率</span></span>
<span class="line"><span style="color:#24292E;">  b2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (iLine.d.y </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> iLine.o.y) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (iLine.d.x </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> iLine.o.x); </span><span style="color:#6A737D;">// iLine.d 多边形线段的终点、iLine.o 是多边形线段的起点</span></span>
<span class="line"><span style="color:#24292E;">  a1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ey </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b1 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> ex;</span></span>
<span class="line"><span style="color:#24292E;">  a2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> iLine.o.y </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b2 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> iLine.o.x;</span></span>
<span class="line"><span style="color:#24292E;">  xi </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">(a1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> a2) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> (b1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b2); </span><span style="color:#6A737D;">// 求俩个直接的交点，即求出交点的 x 坐标 即 xi = a1 - a2 / b2;</span></span></code></pre></div><h2 id="点在多边形内的其他方法" tabindex="-1">点在多边形内的其他方法 <a class="header-anchor" href="#点在多边形内的其他方法" aria-label="Permalink to &quot;点在多边形内的其他方法&quot;">​</a></h2><ol><li><p>用 canvas 自身的 api isPointInPath</p></li><li><p>将多边形切割成多个三角形，然后判断点是否在某个三角形内部</p></li><li><p>转角累加法（点连接各个顶点，计算夹角是否等于 360）</p></li><li><p>面积法 （点连接各个顶点形成三角形，计算面积是否等于图形的面积等）</p></li></ol><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p>1 记录最近的这个物体，下次再次判断这个物体。 2 判断是否是透明区域</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection</a></li><li><a href="https://kenshin.tech/page/2/" target="_blank" rel="noreferrer">https://kenshin.tech/page/2/</a></li></ul>`,39),d=[i];function y(E,h,b,_,g,m){return a(),o("div",null,d)}const f=s(c,[["render",y]]);export{u as __pageData,f as default};
