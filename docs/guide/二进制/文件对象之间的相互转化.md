---
theme: condensed-night-purple
highlight: vs2015
---

# 背景

最近开发过程中遇到了需要文件相关的转化，基于此，通过一篇文章梳理各个文件对象之间的关系。

# 文件对象


## ArrayBuffer

ArrayBuffer 是通用的、固定长度的原始二进制数据缓冲区，它是一个字节数组，在其他语言中也被称为 byte array


例如 创建长度为 8 个字节的 ArrayBuffer

```js
const buffer = new ArrayBuffer(8);

console.log(buffer.byteLength); // 8
```


![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/1ccf9b6c4a7b4f0fadb3e4939473f34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bem6ICz5ZKa:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzU0NDQ4MTIxODQzNTU0OSJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1762997483&x-orig-sign=NJygpVZ%2F7RIK0nKyUxFLmw9D4Qk%3D)


> 可读、不可写，需要通过 类型数组对象（TypedArray） 或者 DataView 进行写操作


## TypedArray 

因为 ArrayBuffer 不可操作，一般会将 ArrayBuffer 转化为 TypedArray 对象 **（可读写）**

TypedArray 是一个底层二进制缓冲区的一个类数组视图

TypedArray 本身是一个接口，有很多实现如 Int8Array、Uint8Array、Int16Array、Uint16Array


| 类型       | 单个元素值范围 |  单元素大小（bytes）| 描述 |
| --------- | ------------ | ---            |  --- |
| Int8Array |  -128 ～ 127 |  1             |  8 位二进制有符号整数  |
| Uint8Array |  0 ～ 255   |  1             |  8 位无符号整数  |
| Int16Array |  -32768 ～ 32767   |  2      |  16 位二进制有符号整数  |
| Uint16Array |  0 ～ 65535   |  2          |  16 位无符号整数  |



![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/bdecc9b79ac5429e81e99bdb98b719c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bem6ICz5ZKa:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzU0NDQ4MTIxODQzNTU0OSJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1762997483&x-orig-sign=wAsh6%2Fq0W%2B7R%2FZ22aJqj64WrWrQ%3D)

上面，我们可以知道 Int8Array 单个元素占据 1 个字节，8 个二进制位。

而 Int16Array 单个元素占据 2 个字节，16 个二进制位。

那么，假设创建了一个 8 个字节长度的 ArrayBuffer 转化成 Int16Array，那么，Int16Array 是多少呢？有兴趣可以试试。


```js
const buffer = new ArrayBuffer(8);
console.log(buffer.byteLength); // 8
const int8Array = new Int8Array(buffer);
console.log(int8Array.length); // 8

const int16Array = new Int16Array(buffer);
console.log(int16Array.length); // ?
```

另外，所有 TypedArray 都有一个 `buffer` 属性，用于返回其底层的 ArrayBuffer。


```js
const buffer = new ArrayBuffer(8);
const uint8Array = new Uint8Array(buffer);
console.log(uint8Array.buffer === buffer); // true
```


## DataView 

**`DataView`** 视图是一个可以从二进制 [`ArrayBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 对象中读写多种数值类型的底层接口，相对于 TypedArray 的固定格式要更加灵活些。

setInt8(offset, value) 方法，可以从偏移量位置开始存储一个 8 个 bit 的数（存一个字节）

getInt8(offset) 则是从 偏移量位置读取一个 8 个 bit 的数。

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/c6d933f97daa47c88ad47937576cf54e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bem6ICz5ZKa:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzU0NDQ4MTIxODQzNTU0OSJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1762997483&x-orig-sign=0nIqYAByHz9fpHM161cE1eXCym0%3D)

```js
const buffer = new ArrayBuffer(2); // 2 个字节的 ArrayBuffer
console.log(buffer.byteLength); // 2
const dataView = new DataView(buffer);
dataView.setInt(0, 1);
dataView.setInt(1, 2);

console.log(dataView.getInt8(0)); // 1
console.log(dataView.getInt8(1)); // 2
console.log(dataView.getInt16(0)); // 258, 取 2 个字节的整数
console.log(dataView.buffer === buffer); // true

```


## Blob

Blob 是不可变的、原始数据的类文件对象 

常见的，可以使用 new Blob(array, type) 创建 Blob 对象，这里的 array 可以是 string[]、ArrayBuffer、ArrayBufferView、Blob


```js
const jsonData = {
   name: "Hello world!",
}
const blob = new Blob([JSON.stringify(jsonData)], { type: "application/json" });
console.log(blob);

function readBlob(blob, type) {
   const { promise, resolve }= Promise.withResolvers();
   let reader = new FileReader();
   
   reader.onload = function(event) {
      resolve(event.target.result);
   }

   switch(type) {
      case "ArrayBuffer":
           reader.readAsArrayBuffer(blob);
           break;
      case "DataURL":
           reader.readAsDataURL(blob); // Base64 字符串
           break;
      case "Text":
           reader.readAsText(blob, 'utf-8');
           break;
   }
   
   return promise;
}

function toAscii(uint8Array) {
  let ascii = '';
  for (let i = 0; i < uint8Array.length; i++) {
    // 转换为ASCII字符并拼接
    ascii += String.fromCharCode(uint8Array[i]);
  }
  
  return ascii;
}

readBlob(blob, "ArrayBuffer").then(result => {
    console.log(`ArrayBuffer`, result);
    const uint8Array = new Uint8Array(result); // uint8Array 的元素是 8 位 bit 的无符号整数（最大 255），
    console.log(`hexToAscii--->`, toAscii(uint8Array)); // 整数转 ASCII 字符
})

readBlob(blob, "DataURL").then(result => {
    console.log(`DataURL`, result);
})

readBlob(blob, "Text").then(result => {
    console.log(`Text`, result);
})
```

输出打印时，当我们可以打开内存器查看 ArrayBuffer 的内存存储信息。

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/c7d0d2b0f2fa4a0695f274f508d0e06d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bem6ICz5ZKa:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzU0NDQ4MTIxODQzNTU0OSJ9&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1762479856&x-orig-sign=qlt9MJZvpTswWSwtMtbZDlnq2B0%3D)

此时，我们发现内存地址存储的是 16 进制的数，将 16 进制转 ASCII 码的操作，便可以得到文件内容了。


```js
function hexToAscii(hex) {
  // 移除可能存在的空格或0x前缀
  hex = hex.replace(/\s|0x/g, '');
  let ascii = '';
  
  // 每两位16进制数转换为一个ASCII字符
  for (let i = 0; i < hex.length; i += 2) {
    // 截取两位16进制数并转换为十进制
    const decimal = parseInt(hex.substr(i, 2), 16);
    // 转换为ASCII字符并拼接
    ascii += String.fromCharCode(decimal);
  }
  
  return ascii;
}

console.log(hexToAscii('7B226E616D65223A2268656C6C6F20776F726C6421227D')); // { "name": "hello world!" }
```

通过前面的学习，我们知道 ArrayBuffer 是不可操作的，我们需要将 ArrayBuffer 转化为 TypedArray 对象或者 DataView 对象，然后进行读写操作。

因此，我们将 ArrayBuffer 转化成 Uint8Array 即8位无符号整数数组(数组中最大整数只能是255)。

因为 Uint8Array 的元素是十进制数，因此，我们需要不需要将 16 进制转十进制，直接将十进制数转 ASCII 码即可。


```js
    function toAscii(uint8Array) {
        let ascii = '';
        for (let i = 0; i < uint8Array.length; i++) {
            // 转换为ASCII字符并拼接
            ascii += String.fromCharCode(uint8Array[i]);
        }
        
        return ascii;
    }
    const uint8Array = new Uint8Array(result); // uint8Array 的元素是 8 位 bit 的无符号整数（最大 255），
    console.log(`toAscii--->`, toAscii(uint8Array)); // 整数转 ASCII 字符 { "name": "hello world!" }
```

似乎一切都在按我们的预期进行，但是，当我们尝试读取一个包含中文的文件时，我们会发现，读取到的内容是乱码。

```js
    const jsonData = {
    name: "Hello world!我是中文",
    }
    const blob = new Blob([JSON.stringify(jsonData)], { type: "application/json" });

    readBlob(blob, "ArrayBuffer").then(result => {
        console.log('-------- uint8Array start --------');
        const uint8Array = new Uint8Array(result); // uint8Array 的元素是 8 位 bit 的无符号整数（最大 255）
        console.log('-------- uint8Array end --------');
        console.log('-------- toAscii start --------');
        console.log(`toAscii--->`, toAscii(uint8Array)); // 整数转 ASCII 字符 { "name": "hello world!" }
        console.log('-------- toAscii end --------');
    })
```

![乱码问题](./../../public/assets/二进制/11.png)


我们发现，读取到的内容是乱码，这是因为什么呢？

在解决乱码问题之前，我们需要先了解一些字符编码的知识。

字符是不能直接存入计算机的。

起初，美国人将需要的字符（英文字母、数字、标点符号、特殊字符）挨个从 0 开始到 127 进行编号，总共 128 个字符。

然后再将 0 到 127 转换成对应的二进制数字。0 到 127 就称为码点，对应的二进制就是编码，再通过 字符集 映射成对应的字符。

这里的 **字符集** 就是 ASCII 字符集。


![ASCII 字符集](./../../public/assets/二进制/12.png)


### ASCII 字符集

ASCII(American Standard Code for Information Interchange)：美国信息交换标准代码，包括了英文、符号等。

标准ASCII字符集使用1个字节存储一个字符，首位是0，总共可表示128个字符，对美国人来说完全够用。

但对于中文的话，ASCII 字符集无法表示，因此，我们需要使用其他字符集来表示中文。

### GBK





### Unicode字符集(统一码，也叫万国码)


### 乱码问题

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/27303a93896143e3980cef87ba8f0a8d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bem6ICz5ZKa:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzU0NDQ4MTIxODQzNTU0OSJ9&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1762480719&x-orig-sign=xyD0EZJPjDoa4bYmcL0EgRbhXL0%3D)



基于此，我们可以知道，ASCII 字符集只能表示 128 个字符，因此，当我们读取一个中文字符的编码时，转化成对应的 ASCII 字符时，但 ASCII 字符集没有这个字符，因此，我们会发现，读取到的内容是乱码。

为了解决这个问题，我们需要使用更全面的 Unicode 字符集。

```js
console.log(String.fromCharCode(0x4E2D)); // 中
```



## Object URL



## Base64


